<!-- build time:Fri Feb 23 2018 23:31:07 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、"><meta property="og:type" content="article"><meta property="og:title" content="优化"><meta property="og:url" content="laiqun.github.io/2018/01/07/optimization/index.html"><meta property="og:site_name" content="广阔天地，大有作为"><meta property="og:description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的使用该方法的典型场景：存在大量可能的题解，以至于我们无"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="/2018/01/07/optimization/climb.jpg"><meta property="og:image" content="/2018/01/07/optimization/localmin.jpg"><meta property="og:image" content="/2018/01/07/optimization/mutate.jpg"><meta property="og:image" content="/2018/01/07/optimization/cross.jpg"><meta property="og:image" content="/2018/01/07/optimization/poor.jpg"><meta property="og:image" content="/2018/01/07/optimization/confuse.jpg"><meta property="og:image" content="/2018/01/07/optimization/clean.jpg"><meta property="og:image" content="/2018/01/07/optimization/crossform.jpg"><meta property="og:image" content="/2018/01/07/optimization/crossans.png"><meta property="og:image" content="/2018/01/07/optimization/crossansw.png"><meta property="og:image" content="/2018/01/07/optimization/nocross.jpg"><meta property="og:updated_time" content="2018-01-21T13:57:08.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="优化"><meta name="twitter:description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的使用该方法的典型场景：存在大量可能的题解，以至于我们无"><meta name="twitter:image" content="/2018/01/07/optimization/climb.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="laiqun.github.io/2018/01/07/optimization/"><title>优化 | 广阔天地，大有作为</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">广阔天地，大有作为</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">你看到我的筋斗云了嘛？</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="laiqun.github.io/2018/01/07/optimization/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的土豆"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="广阔天地，大有作为"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">优化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-07T16:03:00+08:00">2018-01-07 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/01/07/optimization/#comments" itemprop="discussionUrl"><span class="post-comments-count gitment-comments-count" data-xid="/2018/01/07/optimization/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本章将会教大家，如何使用一系列的<strong>随机优化</strong> 的技术来解决协作类问题。<br>这种技术擅长处理：</p><ol><li>结果受多种变量影响</li><li>有许多可能题解</li><li>结果是变量的组合，变量组合变化，结果也跟着变</li></ol><p>应用场景举例：</p><ol><li>物理学 研究分子的运动</li><li>生物学 预测蛋白质的结构</li><li>计算机 确定算法的最坏运行时间</li><li>NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的</li></ol><p>使用该方法的典型场景：存在大量可能的题解，以至于我们无法对它们进行一一尝试。<br>那么优化算法怎么找到一个问题的最优解的呢？<br>优化算法通过尝试许多不同题解，并给这些题解打分以确定题解的质量来找到一个问题的最优解。<br>最简单和最低效的做法的求解方法，进行上千次随机猜测，从随机猜测的题解中找出最佳解；更有效率的方法是以一种可能对题解有改进的方式来智能的修正现有的题解。<br>本文会演示3个例子来展示优化算法：<br>第一个例子是制定组团旅游计划：这个问题要考虑不同的输入：每个人的航班时间表、租用多少汽车、哪个飞机场比较顺畅。结果要考虑许多因素：总的花费、候机时间、飞机飞行的时间。对于这个问题，输入到输出之间的关系无法用简单的映射来表示。想找到最优解，必须借助优化算法。<br>第二个例子是如何基于人们的偏好来分配有限的资源。<br>第三个例子是如何用最小的交叉线来可视化网络结构。<br>第二个例子和第三个例子用于展示优化算法的灵活性。<br>最后，我们给出其他可以用到优化算法的场景。</p><h1 id="组团旅游问题"><a href="#组团旅游问题" class="headerlink" title="组团旅游问题"></a>组团旅游问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安排来自不同地方的人们到同一个地方旅游。<br>我们下创建一个python文件，写下不同的人物和它们的所在地信息。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">people = [(<span class="string">'Seymour'</span>,<span class="string">'BOS'</span>), <span class="comment"># 每一项的格式为人物名  所在地的机场名</span></span><br><span class="line">          (<span class="string">'Franny'</span>,<span class="string">'DAL'</span>),</span><br><span class="line">          (<span class="string">'Zooey'</span>,<span class="string">'CAK'</span>),</span><br><span class="line">          (<span class="string">'Walt'</span>,<span class="string">'MIA'</span>),</span><br><span class="line">          (<span class="string">'Buddy'</span>,<span class="string">'ORD'</span>),</span><br><span class="line">          (<span class="string">'Les'</span>,<span class="string">'OMA'</span>)]</span><br><span class="line"><span class="comment"># 目的地机场</span></span><br><span class="line">destination=<span class="string">'LGA'</span> <span class="comment"># New York的LAGuardia机场</span></span><br></pre></td></tr></table></figure><p></p><p>这些人来自各个地方，他们希望在纽约会面，他们将在同一天到达，在同一天回家。他们在纽约过夜一晚上，第二天返回原住地。他们想租汽车载着他们所有人往返机场。<br>下面我们来看一下航班数据，这些数据在文件scheule.txt中。<br>该文件的每一行代表一个航班数据,逗号作为数据项之间的间隔:<br>格式为: 起飞机场,目的地机场，起飞时间，抵达时间，费用<br>举例：</p><blockquote><p>LGA,MIA,20:27,23:42,169<br>MIA,LGA,19:53,22:21,173<br>LGA,BOS,6:39,8:09,86<br>BOS,LGA,6:17,8:26,89<br>LGA,BOS,8:23,10:28,149</p></blockquote><p>我们将这些数据载入到字典中，以(起点、终点)这样的元组为字典的键，以航班的详细信息为值，注意这里的值是一个列表，因为从起点到终点可能有多个航班。我们将这个列表排序，列表中的第一项代表第一个航班，第二项代表第二个航班，以此类推。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flights=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file(<span class="string">'schedule.txt'</span>):</span><br><span class="line">  origin,dest,depart,arrive,price=line.strip( ).split(<span class="string">','</span>)</span><br><span class="line">  flights.setdefault((origin,dest),[])</span><br><span class="line">  <span class="comment"># Add details to the list of possible flights</span></span><br><span class="line">  flights[(origin,dest)].append((depart,arrive,int(price)))</span><br></pre></td></tr></table></figure><p></p><p>为了方便的计算飞机飞行时间和候机时间，我们还需要编写一个工具函数，该函数计算给定时间在一天内的分钟数。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getminutes</span><span class="params">(t)</span>:</span></span><br><span class="line">       x=time.strptime(t,<span class="string">'%H:%M'</span>)</span><br><span class="line">       <span class="keyword">return</span> x[<span class="number">3</span>]*<span class="number">60</span>+x[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p></p><p>那他们中的每个成员应该坐哪个航班呢？<br>对于这个问题，降低总票价是一个目标，除此之外，还要考虑其他因素，如最小化总的候机时间或最小化总的飞行时间。</p><h2 id="题解描述"><a href="#题解描述" class="headerlink" title="题解描述"></a>题解描述</h2><p>当处理类似这样的优化问题时，我们必须明确潜在的题解应该如何表达。<br>因为后文中介绍的优化函数是非常通用的，它能应用在许多不同类型的问题上，因此我们需要选择一个题解的简单表示方式，要求这种表示方法不仅能表示当前问题的题解，还可以作为通用的题解表示方式。<br>这里我们使用数字序列来描述题解。<br>在本例中，一个数字代表某人乘坐的航班，因为每个人都都需要往返两个航班，故列表的长度是人数的的两倍。<br>[1,4,3,2,7,3,6,3,2,4,5,3] #数字0代表第1次航班，数字1代表第2次航班，以此类推。<br>上述列表描述了一种题解，数字1和4分别代表第2次航班和第5次航班，这表示Seymour搭乘当天的从Boston飞往New York的第2次航班，然后搭乘当天的从New York到Boston的第5次航班返回Boston。Franny是搭乘从Dallas到New York的第4次航班，并搭乘从New York到Dallas的第3次航班返回。<br>因为要从一列数字中解释清楚题解是很难的，所以我们写一个函数，能够将人们决定搭乘的所有航班打印成表格。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printschedule</span><span class="params">(r)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(r)/<span class="number">2</span>):</span><br><span class="line">    name = people[d][<span class="number">0</span>]</span><br><span class="line">    origin = people[d][<span class="number">1</span>]</span><br><span class="line">    out = flights[(origin,destination)][r[<span class="number">2</span>*d]] <span class="comment">#出行 out=[出发时间，返回时间，费用]</span></span><br><span class="line">    ret = flights[(origin,destination)][r[<span class="number">2</span>*d+<span class="number">1</span>]] <span class="comment">#返回</span></span><br><span class="line">    print(<span class="string">'%10s%10s %5s-%5s %3s %5s-%5s %3s'</span> % (name,origin,out[<span class="number">0</span>],out[<span class="number">1</span>],out[<span class="number">2</span>],ret[<span class="number">0</span>],ret[<span class="number">1</span>],ret[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p></p><p>我们来测试一下该函数，其打印的每一行格式为：人名、起点、出发时间、到达时间、票价、返航的出发时间、返航的到达时间、返航票价。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour  Boston 12:34-15:02 $109 12:08-14:05 $142</span></span><br><span class="line"><span class="comment"># Franny  Dallas 12:19-15:25 $342  9:49-13:51 $229</span></span><br><span class="line"><span class="comment">#  Zooey  Akron  9:15-12:14 $247 15:50-18:45 $243</span></span><br><span class="line"><span class="comment">#   Walt  Miami 15:34-18:11 $326 14:08-16:09 $232</span></span><br><span class="line"><span class="comment">#  Buddy  Chicago 14:22-16:32 $126 15:04-17:23 $189</span></span><br><span class="line"><span class="comment">#    Les  Omaha 15:03-16:42 $135  6:19- 8:13 $239</span></span><br></pre></td></tr></table></figure><p></p><p>我们现在来简单看一下这个题解的质量，我们发现Les会乘坐早上6点19的乘坐返航的飞机回家，因为他们往返机场都坐大巴士一起走的，所以即使Zooey虽然是下午3点50的航班，但也要和Les一起在早上6点19之前到达机场，很明显这样的组合不是很理想的，Zooey的候机时间太长。<br>为了确定最佳组合，我们需要一种方法来对题解进行评估，从而决定哪一个方案是最好的。</p><h2 id="题解评价（成本函数）"><a href="#题解评价（成本函数）" class="headerlink" title="题解评价（成本函数）"></a>题解评价（成本函数）</h2><p>成本函数是用优化算法解决问题的关键，它通常是最难确定的。任何优化算法的目标，就是寻找一组能够使成本函数达到最小值的输入。<br>成本函数用一个数值表示方案的好坏，其值越大，代表方案越差。<br>我们需要从众多变量来度量方案的好坏，以下是可能要考虑的度量因素。</p><ol><li>价格<br>所有航班的总票价，或者是考虑到每个旅客收入水平之后的加权平均。</li><li>飞行时间<br>每个旅客在飞机上花费的总时间。</li><li>等待时间<br>每个旅客在候机场等飞机的时间。以及一个旅客达到后，等待其他旅客的时间。</li><li>出发时间<br>越早的航班要求旅客越早起床，这会导致旅客的睡眠时间减少。</li><li>大巴的租用天数<br>大巴从起租时刻起，24小时内换回去，否则需要多租一天的巴士。巴士按天来租的。</li></ol><p>当我们为一个复杂问题寻找最佳方案的时候，倒要明确什么是最重要的因素。尽管寻找最重要的因素是由难度的，但一旦找到重要因素，制作少量的修改，便可以将优化算法来解决这个问题。<br>选择好对成本产生影响的一些变量之后，我们要寻找办法将他们组合在一起形成一个值。<br>例如在本例中，我们就有必要明确，在飞机上飞行的时间和在机场等待的时间怎么换算成价值，比如我们可以规定，飞机的飞行时间每减少1分钟，价值1美元。这意味着多花60美元可以减少1个小时的飞行时间。在机场候机的时间每一分钟价值0.5美元。巴士要租1天,如果超过了24小时，需要多付50美元。<br>下面我们来定义schedulecost函数，该函数考察了总的旅行时间成本以及不同旅客在机场总的等待时间。我们随时可以修改成本函数追加额外的成本，以及调整变量的重要性。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedulecost</span><span class="params">(sol)</span>:</span></span><br><span class="line">  totalprice=<span class="number">0</span></span><br><span class="line">  latestarrival =<span class="number">0</span></span><br><span class="line">  earliestdep = <span class="number">24</span>*<span class="number">60</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(sol)/<span class="number">2</span>):</span><br><span class="line">    <span class="comment">#得到去纽约的航班 以及从纽约回到原住地的航班</span></span><br><span class="line">    origin=people[d][<span class="number">1</span>]<span class="comment">#people每一项格式为 人名 原住地</span></span><br><span class="line">    outbound = flights[(origin,destination)][int(sol[<span class="number">2</span>*d])]<span class="comment">#格式为出发时间 到达时间 费用</span></span><br><span class="line">    returnf = flights[(destination,origin)][int(sol[<span class="number">2</span>*d+<span class="number">1</span>])]    </span><br><span class="line">    totalprice+=outbound[<span class="number">2</span>]</span><br><span class="line">    totalprice+=returnf[<span class="number">2</span>]</span><br><span class="line">   <span class="comment">#记录最晚到达的航班和最早离开的航班</span></span><br><span class="line">    <span class="keyword">if</span> latestarrival&lt;getminutes[outbound[<span class="number">1</span>]]:</span><br><span class="line">      latestarrival =getminutes[outbound[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">if</span> earliestdep&gt;getminutes[returnf[<span class="number">0</span>]]:</span><br><span class="line">      earliestdep=getminutes[returnf[<span class="number">0</span>]]</span><br><span class="line">    <span class="comment">#每个人必须在机场等待最后一个人的到达</span></span><br><span class="line">    <span class="comment">#他们返回时做同一个大巴，同一时间达到机场，等待他们的航班</span></span><br><span class="line">  totalwait=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(sol)/<span class="number">2</span>):</span><br><span class="line">    origin = people[d][<span class="number">1</span>]</span><br><span class="line">    outbound = flights[(origin,destination)][int(sol[<span class="number">2</span>*d])]<span class="comment">#格式为出发时间 到达时间 费用</span></span><br><span class="line">    returnf = flights[(destination,origin)][int(sol[<span class="number">2</span>*d+<span class="number">1</span>])]    </span><br><span class="line">    totalwait+=latestarrival-getminutes(outbound[<span class="number">1</span>])</span><br><span class="line">    totalwait+=getminutes(returnf[<span class="number">0</span>])-earliestdep</span><br><span class="line">  <span class="keyword">if</span> latestarrival&lt;earliestdep:  </span><br><span class="line">  <span class="comment">#举例如果是早上6点租的，最早回去的是早上7点的航班</span></span><br><span class="line">  <span class="comment">#租的时间超过了24小时未还，需要多付50美元</span></span><br><span class="line">    totalprice+=<span class="number">50</span></span><br><span class="line">  <span class="keyword">return</span> totalprice+totalwait</span><br></pre></td></tr></table></figure><p></p><p>上述函数中的逻辑虽然非常简单，但是它却阐明了关键的因素。<br>我们还可以采用若干方法对其功能进行进行增强。<br>目前，总的等待时间的计算是假定：先到达纽约机场的旅客要等待最后一名达到机场的旅客。所有的旅客都有陪同最早回去的旅客到纽约机场，等他们各自的航班。<br>我们可以对方案的约束条件进行修改，如果旅客需要等待2小时以上时，他们可以自行搭出租，而不再需要一起坐巴士;我们还可以时间与价值量之间的权重，比如一分钟价值更多的美元或者更少的美元。<br>尝试运行一下上述函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedulecost([<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p></p><p>成本函数已经建立，那么应该很清楚，我们的目标就是通过选择比较合适的数字序列来最小化该成本函数。<br>里面上，我们可以尝试每种可能的组合，但这个例子中，假设每天有10个航班，达到纽约一个人有10种选择，那么6个人就有10000000种可能，如果算上返回的航班组合，又是1000000。将这两个组合起来就是10的12次方种方案，大概是1000亿。测试每种组合可以确保我们找到最优的方案，但这样将花费非常长的时间。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><p>随机搜索不是一种非常好的优化算法，但是它却能使我们很容易领会的优化算法，就是随机猜呗。<br>这个函数接受两个参数。Domain是一个由二元组构成的列表，它指定额每个变量的最大值和最小值。用它来标识题解的搜索空间。在当前的例子中，每个人都有10种去纽约的航班和10种从纽约回到原住地的航班。因此domain是（0，9），每个人重复两次。<br>第二个参数，costf，是成本函数，本例中即为schedulecost。将成本函数作为参数传入是为了让这个随机搜索方法的优化函数能够被其他优化问题所用。<br>这个随机优化函数将会进行1000次猜测，然后对每种猜测计算成本，选中其中最好的题解。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomoptimize</span><span class="params">(domain,costf)</span>:</span></span><br><span class="line">  best = <span class="number">999999999</span></span><br><span class="line">  bestr = <span class="keyword">None</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment">#创建一个随机解</span></span><br><span class="line">    r=[random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i range(len(domain))]</span><br><span class="line">    <span class="comment">#计算这个随机解的成本</span></span><br><span class="line">    cost = costf(r)</span><br><span class="line">    <span class="comment">#与保留的历史最优解比较</span></span><br><span class="line">    <span class="keyword">if</span> cost&lt;best:</span><br><span class="line">      best = cost</span><br><span class="line">      bestr = r</span><br><span class="line">  <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p></p><p>1000次猜测只占全部可能的一小部分。我们可以随机猜测到不少表现还可以的题解，因为在猜测1000次后，该函数有可能得到一个看似不算很差的题解。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">domain=[(<span class="number">0</span>,<span class="number">9</span>)*(len(people)*<span class="number">2</span>)]</span><br><span class="line">s=randomoptimize(domain,schedulecost)<span class="comment">#得到随机猜测中的最优解</span></span><br><span class="line">schedulecost(s)<span class="comment">#计算猜测到的最优解的成本</span></span><br><span class="line">printschedule(s)<span class="comment">#打印结果</span></span><br><span class="line">Seymour  Boston <span class="number">12</span>:<span class="number">34</span><span class="number">-15</span>:<span class="number">02</span> $<span class="number">109</span> <span class="number">12</span>:<span class="number">08</span><span class="number">-14</span>:<span class="number">05</span> $<span class="number">142</span></span><br><span class="line"> Franny  Dallas <span class="number">12</span>:<span class="number">19</span><span class="number">-15</span>:<span class="number">25</span> $<span class="number">342</span>  <span class="number">9</span>:<span class="number">49</span><span class="number">-13</span>:<span class="number">51</span> $<span class="number">229</span></span><br><span class="line">  Zooey   Akron  <span class="number">9</span>:<span class="number">15</span><span class="number">-12</span>:<span class="number">14</span> $<span class="number">247</span> <span class="number">15</span>:<span class="number">50</span><span class="number">-18</span>:<span class="number">45</span> $<span class="number">243</span></span><br><span class="line">   Walt   Miami <span class="number">15</span>:<span class="number">34</span><span class="number">-18</span>:<span class="number">11</span> $<span class="number">326</span> <span class="number">14</span>:<span class="number">08</span><span class="number">-16</span>:<span class="number">09</span> $<span class="number">232</span></span><br><span class="line">  Buddy Chicago <span class="number">14</span>:<span class="number">22</span><span class="number">-16</span>:<span class="number">32</span> $<span class="number">126</span> <span class="number">15</span>:<span class="number">04</span><span class="number">-17</span>:<span class="number">23</span> $<span class="number">189</span></span><br><span class="line">    Les   Omaha <span class="number">15</span>:<span class="number">03</span><span class="number">-16</span>:<span class="number">42</span> $<span class="number">135</span>  <span class="number">6</span>:<span class="number">19</span>- <span class="number">8</span>:<span class="number">13</span> $<span class="number">239</span></span><br></pre></td></tr></table></figure><p></p><p>由于是随机的原因，你看到结果可能和这里不一样。上述结果不算很好，因为去纽约机场时，Zooey要等6个小时直到Walt到达。<br>我们可以多执行几次该函数，也可以将循环次数修改为10000，看看是不是能找到更有的结果。</p><h3 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h3><p>随机尝试各种题解是非常低效的，因为这种方法没有充分利用已经发现的优解。在我们的例子中，拥有较低成本的题解周围可能存在更优的题解。随机优化的题解是跳跃的，它不会充分利用已经发现的优解。<br>随机搜索的一种替代方法叫做爬山法。爬山法以一个随机解开始，然后在其临近的解集中寻找更好的解，更好的解拥有更低的成本。这类似于从斜坡上向下走，如图所示：<br><img src="/2018/01/07/optimization/climb.jpg" title="用爬山法寻找最低成本"><br>想象一下牛就是图中的那个人，不经意间陷入了这块区域中，并且想走到最低点去寻找水源。为此我们可以选择任何一个方向，然后朝着最为险峻的斜坡向下走去。你可以朝着最为险峻的斜坡方向一致走下去，直到达到地势平坦或者坡度开始向上倾斜的区域。<br>该优化方法的具体过程是：先从一个随机的方案开始，然后再找到所有与之相邻的题解。在本例中，即找到所有相对最初的题解，我们依次的挑出一个人，让他尝试乘坐稍早或者稍晚的航班。我们对这些相邻题解都计算成本，这一组相邻题解中最低成本的将成为新的题解。重复这个过程，直到不能改善为止。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hillclimb</span><span class="params">(domain,costf)</span>:</span></span><br><span class="line">  <span class="comment">#创建一个随机解</span></span><br><span class="line">  sol=[random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment">#生成相邻题解的集合</span></span><br><span class="line">    neighbors=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(domain)):</span><br><span class="line">      <span class="comment">#依次将每一项都提前或者延后一点的题解加入题解集合</span></span><br><span class="line">      <span class="keyword">if</span> sol[j]&gt;domain[j][<span class="number">0</span>]:<span class="comment">#最小值</span></span><br><span class="line">        neighbors.append(sol[<span class="number">0</span>:j]+[sol[j]<span class="number">-1</span>]+sol[j+<span class="number">1</span>:])</span><br><span class="line">      <span class="keyword">if</span> sol[j]&lt;domain[j][<span class="number">1</span>]:<span class="comment">#最大值</span></span><br><span class="line">        neighbors.append(sol[<span class="number">0</span>:j]+[sol[j]+<span class="number">1</span>]+sol[j+<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">#在相邻题解的集合中寻找最优解</span></span><br><span class="line">    current = costf(sol)</span><br><span class="line">    best = current<span class="comment">#得分</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(neighbors)):</span><br><span class="line">      cost = costf(neighbors[j])</span><br><span class="line">      <span class="keyword">if</span> cost&lt;best:</span><br><span class="line">        best = cost</span><br><span class="line">        sol = neighbors[j]</span><br><span class="line">    <span class="comment">#如果没有更好的解，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> best == current:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> sol</span><br></pre></td></tr></table></figure><p></p><p>该函数在更定的域内随机生成了一个数字列表，用以构造初始的题解。它通过循环遍历列表中的每一个元素，将其加1和减一的题解作为新的题解，将新题解加入题解集合。然后对题解集合中的每一项计算成本函数，选择当前题解集合中的最优解。然后将这个题解作为初始解，重复上述过程。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hillclimb(domain,schedulecost) </span><br><span class="line">schedulecost(s)<span class="comment">#计算成本 </span></span><br><span class="line"><span class="comment">#3063</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour BOS 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny DAL 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey CAK 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt MIA 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy ORD 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les OMA 11:08-13:07 $175 18:25-20:34 $205</span></span><br></pre></td></tr></table></figure><p></p><p>该函数运行速度很快，并且找到的题解通常要比随机搜索找到的题解更优。然后，爬山法有一个很大的缺陷。如下图所示：<br><img src="/2018/01/07/optimization/localmin.jpg" title="陷入局部范围内的最小值"><br>从上图中我们可以明显的看出，简单的从斜坡滑下到达的可能未必是全局的最低点。最后的题解是一个局部范围内的最小值，它比临近的表现都好，但却不是全局最优的。全局最优解就是全局最小值，它是优化算法最终应该找到的那个题解。<br>解决这一难题的一种方法是随机重复爬山法，即让爬山法以多个随机生成的初始解为起点运行若干次，借此希望其中有一个能逼近全局的最小值。后面的模拟退火算法和遗传算法都是避免陷入局部最小值的优化方法。</p><h3 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h3><p>模拟退火算法是受物理学领域的启发而来的一种优化算法。退火是指将合金加热后再慢慢冷却的过程。大量的原子在温度较高时向周围跳跃，然后逐渐冷却，原子的性质逐渐稳定。<br>退火算法以一个问题的随机解开始，它用一个变量来表示温度，这个温度开始时非常高，然后逐渐变低。每一次迭代，算法会随机选择题解中的某个数字，然后朝着某个方向变化。然后计算其前后变化的成本，进行比较。<br>算法最为关键的部分在于：如果新的成本更低，则新的题解将会成为当前题解，这和爬山法类似。不过，如果成本更高的话，新的题解仍然有可能成为当前题解。这是避免局部最小值问题的一种方法。<br>某些情况下，在我们能够得到一个更优的解之前转向一个更差的解是很有必要的。模拟退火算法之所以管用，不仅因为它总是接受一个更优的解，还有就是他在退火过程的开始阶段会接受表现较差的解。随着退火过程的不断进行，算法越来越不可能接受较差的解，直到最后，它将只会接受更优的解。其接受差解的概率公式为：<br>p=e^((-highcost–lowcost)/temperature)<br>温度表示接受差解的意愿，开始非常高，指数将接近为0，所以概率几乎为1。随着温度的递减，高成本和低成本之间的差异越重要，差异越大，概率越低，因此该算法只倾向于稍差的解而不是非常差的解。<br>我们来书写annealingoptimize函数，来实现上述算法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annealingoptimize</span><span class="params">(domain,costf,T=<span class="number">10000.0</span>,cool=<span class="number">0.95</span>,step=<span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="comment">#随机初始化值</span></span><br><span class="line">  vec = [float(random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">  <span class="keyword">while</span> T &gt;<span class="number">0.1</span>:</span><br><span class="line">    <span class="comment">#选择一个索引值</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(domain)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#选择一个改变索引值的方向</span></span><br><span class="line">    dir = random.randint(-step,step)</span><br><span class="line">    <span class="comment">#创建一个代表题解的新列表，改变其中一个值</span></span><br><span class="line">    vecb=vec[:]</span><br><span class="line">    vecb[i]+=dir</span><br><span class="line">    <span class="keyword">if</span> vecb[i]&lt;domain[i][<span class="number">0</span>]:</span><br><span class="line">      vecb[i]=domain[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> vecb[i]&gt;domain[i][<span class="number">1</span>]:</span><br><span class="line">      vecb[i]=domain[i][<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#计算当前成本和新的成本</span></span><br><span class="line">    ea = costf(vec)</span><br><span class="line">    eb = costf(vecb)</span><br><span class="line">    <span class="comment">#它是更好的解吗？或者取向最优解的可能解吗？</span></span><br><span class="line">    <span class="keyword">if</span> (eb&lt;ea <span class="keyword">or</span> random.rendom()&lt;pow(math.e,-(eb-ea)/T)):</span><br><span class="line">      vec=vecb</span><br><span class="line">    T=T*cool</span><br><span class="line">  <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p></p><p>为了退火，函数首先创建一个具有合适长度的随机解，其中所有值都位于定义域参数指定的范围内。<br>温度和冷却率是两个可选的参数。函数会在每次迭代时，将i设置为题解的一个随机索引，并将dir设置为介于-step和step之间的某个随机数。该算法会计算当前题解的成本，以及以i为索引增量dir的题解的成本。<br>概率计算的部分，概率的值会随着T的降低而降低。如果介于0到1之间的随机浮点数小于该值，或者新的题解更优，那么该函数会接受新的题解。函数会一致循环直到温度降到接近0为止，每次循环都会将温度值与冷却率相乘。<br>现在我们可以尝试运行该函数。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s=annealingoptimize(domain,schedulecost)</span><br><span class="line">schedulecost(s)</span><br><span class="line"><span class="comment">#2278</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour  Boston 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny  Dallas 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey   Akron 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt   Miami 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy Chicago 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les   Omaha 11:08-13:07 $175 15:07-17:21 $129</span></span><br></pre></td></tr></table></figure><p></p><p>你可能会得到不同的结果，深圳碰巧会得到一个较差的结果。对于任何一个给定的问题，可以尝试不同的参数来做试验，比如修改初始温度和冷却率，或者修改step值的大小。</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法也是受自然科学的启发。这类算法的运行过程是先随机生成一组解，我们称之为种群。<br>在优化算法的每一步，算法会计算整个种群的成本函数，从而得到一个题解与评分的有序列表。如下表所示。</p><table><thead><tr><th>题解</th><th>成本</th></tr></thead><tbody><tr><td>[7,5,2,3,1,6,1,6,7,1,0,3]</td><td>4394</td></tr><tr><td>[7,2,2,2,3,3,2,3,5,2,0,8]</td><td>4661</td></tr><tr><td>…</td><td>…</td></tr><tr><td>[0,4,0,3,8,8,4,4,8,5,6,1]</td><td>7845</td></tr><tr><td>[5,8,0,2,8,8,8,2,1,6,6,8]</td><td>8088</td></tr></tbody></table><p>在对题解进行排序之后，下一步我们要基于现有的种群产生一个新的种群——我们称之为下一代。<br>首先，我们将当期种群中位于最顶端的题解加入新种群，这一过程为<strong>精英选拔法</strong>。新种群中余下部分是修改最优解后形成的全新解组成的。<br>有两种修改题解的方法，其中一种较为简单的方法叫做<strong>变异</strong>，其通常的做法是对一个现有的题解进行微小的、简单的、随机的改变。<br>在本例中，要完成题解的变异只需要从题解中选择一个数字，然后对其进行递增或者递减即可。如下图所示：<br><img src="/2018/01/07/optimization/mutate.jpg" title="变异"><br>修改题解的另一种方法称之为<strong>分叉</strong>或者<strong>配对</strong>。这种方法是选取最优解中的两个解，然后将他们按某种方式进行组合。在本例中，要实现交叉的一种简单方式是，从一个解中随机取出一个数字作为新题解中的某些元素，而剩余的元素来自于另外一个题解。图下图所示：<br><img src="/2018/01/07/optimization/cross.jpg" title="配对"><br>一个新的种群是通过对最优解进行随机的<strong>变异</strong>和<strong>配对</strong>处理构造出来的，它的数目通常与旧种群的数目相同。这个过程会重复的进行——新的种群经过排序，又一个新种群被构造出来。达到指定的迭代次数，或者之后经过数代后题解都没有得到改善，整个过程就结束了。<br>下面我们编写函数实现上述算法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneticoptimize</span><span class="params">(domain,costf,popsize=<span class="number">50</span>,step=<span class="number">1</span>,mutprob=<span class="number">0.2</span>,elite=<span class="number">0.2</span>,maxiter=<span class="number">100</span>)</span>:</span></span><br><span class="line">  <span class="comment">#变异操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mutate</span><span class="params">(vec)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(domain)<span class="number">-1</span>)<span class="comment">#随机选一项进行变异</span></span><br><span class="line">    <span class="keyword">if</span> random.random()&lt;<span class="number">0.5</span> <span class="keyword">and</span> vec[i]&gt;domain[i][<span class="number">0</span>]:</span><br><span class="line">      <span class="keyword">return</span> vec[<span class="number">0</span>:i]+[vec[i]-step]+vec[i+<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">elif</span> vec[i]&lt;domain[i][<span class="number">1</span>]:</span><br><span class="line">      <span class="keyword">return</span> vec[<span class="number">0</span>:i]+[vec[i]+step]+vec[i+<span class="number">1</span>:]</span><br><span class="line">  <span class="comment">#交叉操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crossover</span><span class="params">(r1,r2)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">1</span>,len(domain)<span class="number">-2</span>)<span class="comment">#确保至少交换1处</span></span><br><span class="line">    <span class="keyword">return</span> r1[<span class="number">0</span>:i]+r[i:]</span><br><span class="line">  <span class="comment">#构造初始种群</span></span><br><span class="line">  pop=[]<span class="comment">#构造一堆随机序列作为初始种群</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(popsize):</span><br><span class="line">    vec = [random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">    pop.append(vec)</span><br><span class="line">  <span class="comment">#每一代中有多少胜出者</span></span><br><span class="line">  topelite = int(elite*popsize)</span><br><span class="line">  <span class="comment">#主循环</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(maxiter):</span><br><span class="line">    scores = [ (cosft(v),v) <span class="keyword">for</span> v <span class="keyword">in</span> pop]<span class="comment">#socres每一项为： 成本 序列</span></span><br><span class="line">    scores.sort()</span><br><span class="line">    ranked=[v <span class="keyword">for</span> (s,v) <span class="keyword">in</span> scores]</span><br><span class="line">    <span class="comment">#只留下胜出者们</span></span><br><span class="line">    pop=ranked[<span class="number">0</span>:topelite]</span><br><span class="line">    <span class="comment">#添加变异和配对后胜出新的种群</span></span><br><span class="line">    <span class="keyword">while</span> len(pop)&lt;popsize:</span><br><span class="line">      <span class="keyword">if</span> random.random&lt;mutprob:</span><br><span class="line">        <span class="comment">#变异 从胜出者中随机选出一个进行变异</span></span><br><span class="line">        c = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        pop.append(mutate(ranked[c]))</span><br><span class="line">      <span class="keyword">else</span>：</span><br><span class="line">        <span class="comment">#配对 从胜出者中随机挑出两个进行配对</span></span><br><span class="line">        c1 = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        c2 = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        pop.append(corssover(ranked[c1],ranked[c2]))</span><br><span class="line">    print(scores[<span class="number">0</span>][<span class="number">0</span>])<span class="comment">#打印最优解的成本</span></span><br><span class="line">  <span class="keyword">return</span> scores[<span class="number">0</span>][<span class="number">1</span>]<span class="comment">#打印最优解的序列</span></span><br></pre></td></tr></table></figure><p></p><p>上述函数中的几个可选的参数：</p><ol><li>popsize 意思是种群大小</li><li>mutprob 种群新成员是由变异而非配对得到的概率</li><li>elite 种群中被认为是优解且被允许传入下一代的部分</li><li>maxiter 最多迭代多少次</li></ol><p>尝试运行一下上述函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">geneticoptimize(domain,schedulecost)</span><br><span class="line"><span class="comment">#3532</span></span><br><span class="line"><span class="comment">#3503</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour BOS 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny DAL 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey CAK 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt MIA 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy ORD 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les OMA 11:08-13:07 $175 11:07-13:24 $171</span></span><br></pre></td></tr></table></figure><p></p><p>后续我们会学习到遗传算法的一个扩展，称为<strong>遗传编程</strong>，在那里我们将使用类似的思路来自动构造程序。</p><blockquote><p>补充： 计算机科学家John Holland 因其在1975年所撰写的《Adaptation in Nature and Artificial System》，被认为是遗传算法之父。但是相关的研究工作可以追溯到1950年，那时的生物学家已经开始尝试在计算机上进行遗传进化的建模了。从那以后，遗传算法和其他优化算法已经被广泛的应用于许多不同的问题。比如:</p><ul><li>用来设计音乐厅的外形，使之能够产生最佳的音效</li><li>给超音速飞机设计最佳的机翼</li><li>加速药物的研发</li><li>自动化设计语音识别芯片<br>我们可以将这些问题的潜在解转化为数字列表。这一我们就可以很容易的应用遗传算法或模拟退火算法了。</li></ul></blockquote><h3 id="优化算法总结"><a href="#优化算法总结" class="headerlink" title="优化算法总结"></a>优化算法总结</h3><p>一种优化方法是否管用很大程序上取决于问题本身。模拟退火算法、遗传算法、以及大多数的其他优化算法都依赖于这样一个假设：对于大多数问题而言，最优解周围应该较多的优解。下面是一个优化算法很难起作用的例子，如下图所示：<br><img src="/2018/01/07/optimization/poor.jpg" title="很难优化的问题"><br>在图的最右边，成本的最低点处于一个非常陡峭的求。接近它的任何解都偶可能被排除在外，因为这些解的成本很高，所以我们可能永远也找不到通全局最小值的途径，大多数算法都会陷入图中左边的某个局部最小化的区域内。<br>优化方法对航班安排的例子之所以有效是因为，我们将一个人从当前的第二次航班转移到第三次航班，要比将他转移到第八次航班更有可能降低总成本。我们会在临近域中进行搜索。如果航班处于无序状态，那么优化方法的效果并不会被随机搜索好——实际上，在这样的情况下，没有任何一种优化方法一定会比随机搜索更加有效。</p><h1 id="涉及偏好的优化——学生宿舍分配问题"><a href="#涉及偏好的优化——学生宿舍分配问题" class="headerlink" title="涉及偏好的优化——学生宿舍分配问题"></a>涉及偏好的优化——学生宿舍分配问题</h1><h2 id="使用优化算法解决问题的前提"><a href="#使用优化算法解决问题的前提" class="headerlink" title="使用优化算法解决问题的前提"></a>使用优化算法解决问题的前提</h2><p>我们已经看到一个可以用优化算法解决问题的例子，但还有许多表面上看起来不相关的问题，可以用同样的方法来解决。<br>使用优化算法解决问题的基本前提是：</p><ol><li>有一个定义好的成本函数</li><li>相似的解会产生相似的结果。</li></ol><p>即使满足上述条件也未必能用优化算法来解决问题，但优化算法可能返回一些此前我们未曾考虑到的值得关注的结果。<br>本小节要考察一类问题：如何将有限的资源分配给多个表达了偏好的人，并尽可能的使他们都满意。即根据他们的意愿，尽可能的满足他们的需要。</p><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>本节的示例问题是，依据学生的首选和次选，为其分配宿舍。尽管这是一个非常具体化的例子，但是将这种情况推广到其他问题是非常容易的——完全相同的代码可以用于在线纸牌游戏玩家的牌桌分配，也可以用于大型编程项目中开发人员bug分配，甚至用户家庭成员的家务分配。需要再次说明的是，这类问题的目的是为了从个体中提取信息，并将其组合起来产生出优化的结果。<br>本例子中有5个宿舍，每个宿舍有两个隔间，由10个学生来竞争住所。每一个学生都有一个首选和一个次选。<br>我们新建一个名为dorm.py的文件，添加10个学生的名字以及他们的首选和次选信息、以及宿舍列表。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment">#代表宿舍，每个宿舍有两个可用的隔间</span></span><br><span class="line">dorms=[<span class="string">'Zeus'</span>,<span class="string">'Athena'</span>,<span class="string">'Hercules'</span>,<span class="string">'Bacchus'</span>,<span class="string">'Pluto'</span>]</span><br><span class="line"><span class="comment">#代表学生以及他的首选和次选</span></span><br><span class="line"> prefs=[(<span class="string">'Toby'</span>, (<span class="string">'Bacchus'</span>, <span class="string">'Hercules'</span>)),</span><br><span class="line">            (<span class="string">'Steve'</span>, (<span class="string">'Zeus'</span>, <span class="string">'Pluto'</span>)),</span><br><span class="line">            (<span class="string">'Andrea'</span>, (<span class="string">'Athena'</span>, <span class="string">'Zeus'</span>)),</span><br><span class="line">            (<span class="string">'Sarah'</span>, (<span class="string">'Zeus'</span>, <span class="string">'Pluto'</span>)),</span><br><span class="line">            (<span class="string">'Dave'</span>, (<span class="string">'Athena'</span>, <span class="string">'Bacchus'</span>)),</span><br><span class="line">            (<span class="string">'Jeff'</span>, (<span class="string">'Hercules'</span>, <span class="string">'Pluto'</span>)),</span><br><span class="line">            (<span class="string">'Fred'</span>, (<span class="string">'Pluto'</span>, <span class="string">'Athena'</span>)),</span><br><span class="line">            (<span class="string">'Suzie'</span>, (<span class="string">'Bacchus'</span>, <span class="string">'Hercules'</span>)),</span><br><span class="line">            (<span class="string">'Laura'</span>, (<span class="string">'Bacchus'</span>, <span class="string">'Hercules'</span>)),</span><br><span class="line">            (<span class="string">'Neil'</span>, (<span class="string">'Hercules'</span>, <span class="string">'Athena'</span>))]</span><br></pre></td></tr></table></figure><p></p><p>你会发现，每个人都不可能满足各自的首选，因为Bacchus仅有两个隔间，而想要住进去的人却有三个。选择其中一个安置在Hercules，你会发现Hercules已经被首选了两次，已经没有多余的空间留给其他人了。<br>为了易于理解，我们有意将这个问题设计的很小巧，但在真实生活中，问题也许会涉及成百上千的学生在更大数量的宿舍中竞争住所。<br>这个例子大概有100 000 个可能的解，这可以有组合公式得到，从10个中选2个，然后从8个中选2个，从6个中选2个…从2个中选2个，将这些选法相乘，就是题解的个数。当每间宿舍有4个隔间时，这个数字会快速增长到上万亿。</p><h2 id="题解的表示"><a href="#题解的表示" class="headerlink" title="题解的表示"></a>题解的表示</h2><p>理论上，我们可以走高一个数字序列，序列的序号代表学生，序号对应的值表示我们将该学生安置在了某一间宿舍。问题在于，这种表达方式无法再题解中体现每个宿舍仅能由两个学生剧组的约束条件。一个全0的序列代表将所有人都安置在了Zeus宿舍，很明显这并不是一个有效的解。<br>解决这一问题的一种方法是让成本函数返回一个很高的数值，用来代表无效解，但是这将是优化算法很难找到次优的解，因为算法无法确定这种无效解周围是否有优解，或者是有效的解。一般而言，我们最好不要让计算机的运算浪费在每一必要的搜索上。<br>解决这一问题更好的办法是寻找一种能让每个解都有效的题解表示法。有效解未必是优解，它仅代表对于每个宿舍，都有有两名同学居住。<br>要达到这个目的，一种办法是设想每个宿舍都有两个槽，然后我们给每一个槽进行编号。对于本例来说有10个槽。我们将每个学生都安置在各个空槽内。一开始列表大小为10，表示有10个槽，列表索引号为0-9，第一个同学可以从10个槽中选择1个，然后删掉选中的槽，剩下9个槽，此时列表索引号变成0-8；第二个学生可以从剩余的9个槽中选择一个，然后删掉这个槽，列表索引号变成0-7；……以此类推。<br>题解的定义域必须满足一个约束，我们来写程序来描述题解的定义域：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[(0,9),(0,8),(0,7),(0,6),...,(0,0)]</span></span><br><span class="line">domain=[(<span class="number">0</span>, len(dorms)-i<span class="number">-1</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(dorms)*<span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p></p><p>由于题解是序列，我们无法直观的进行解释，索引接下来写一个打印题解的函数。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printsolution</span><span class="params">(vec)</span>:</span></span><br><span class="line">  slots=[]</span><br><span class="line">  <span class="comment">#为每个宿舍建立两个槽</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dorms)):</span><br><span class="line">    solts+=[i,i]</span><br><span class="line">  <span class="comment">#遍历每个学生的安置情况</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(vec)):</span><br><span class="line">    x=int(vec[i])</span><br><span class="line">    <span class="comment">#从剩余的槽中选择</span></span><br><span class="line">    dorm = dorms[solts[x]]</span><br><span class="line">    <span class="comment">#输出学生及其被分配的宿舍</span></span><br><span class="line">    print(prefs[i][<span class="number">0</span>],dorm)</span><br><span class="line">    <span class="comment">#删除该槽</span></span><br><span class="line">    <span class="keyword">del</span> solts[x]</span><br></pre></td></tr></table></figure><p></p><p>测试一下这个函数:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printsolution([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#Toby Zeus</span></span><br><span class="line"><span class="comment">#Steve Zeus</span></span><br><span class="line"><span class="comment">#Andrea Athena</span></span><br><span class="line"><span class="comment">#Sarah Athena</span></span><br><span class="line"><span class="comment">#Dave Hercules</span></span><br><span class="line"><span class="comment">#Jeff Hercules</span></span><br><span class="line"><span class="comment">#Fred Bacchus</span></span><br><span class="line"><span class="comment">#Suzie Bacchus</span></span><br><span class="line"><span class="comment">#Laura Pluto</span></span><br><span class="line"><span class="comment">#Neil Pluto</span></span><br></pre></td></tr></table></figure><p></p><p>解释一下上述函数的运行过程。一开始,solts为[0,0,1,1,2,2,3,3,4,4],0号同学可以选择的列表索引号的范围为0-9，0号同学选择了列表索引号为0的宿舍，对应Zeus的第1个槽，然后删除这个槽。1号同学可以选择的列表索引号为0-8，从列表[0,1,1,2,2,3,3,4,4]中选择，他选择了列表索引号为0的宿舍，对应Zeus的第2个槽，删除这个被选择的槽。2号同学可以选择的列表范围为0-7，从列表[1,1,2,2,3,3,4,4]中选择，他选择了列表索引号为0的，即Athena的第1个槽。依次类推。<br>你会发现对第一个同学，其可以选择的列表索引号范围为0-9，第二个同学为0-8，以此类推。题解的每个数值必须有正确的索引范围，即前面定义的domain，我们的优化函数会借助这个参数，来确定题解中每一项的数值范围，这样可以保证生成的都是有效解。</p><h2 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h2><p>成本函数的工作方式与打印题解的函数类似。构造一个槽序列，用过的槽就删除。成本的计算是通过将学生的当前宿舍安排与其偏好项进行比较得到的。如果分配的宿舍是该同学的首选，其总成本增加0，如果分配的宿舍是该同学的次选，增加1，如果分配的宿舍既不是该同学的首选也不是该同学的次选，成本加3。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dormcost</span><span class="params">(vec)</span>:</span></span><br><span class="line">  cost = <span class="number">0</span></span><br><span class="line">  <span class="comment">#为每个宿舍建立两个槽</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dorms)):</span><br><span class="line">    slots+=[i,i]</span><br><span class="line">  <span class="comment">#遍历每一个学生</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(vec)):</span><br><span class="line">    x = int(vec[i])</span><br><span class="line">    <span class="comment">#从剩余槽中选择</span></span><br><span class="line">    dorm = dorms[slots[x]]</span><br><span class="line">    pref = prefs[i][<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#首选成本是0，次选成本是1，不是首选也不是次选，成本是3</span></span><br><span class="line">    <span class="keyword">if</span> pref[<span class="number">0</span>]== dorm:</span><br><span class="line">      cost+=<span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> pref[<span class="number">1</span>]==dorm:</span><br><span class="line">      cost+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      cost+=<span class="number">3</span></span><br><span class="line">    <span class="keyword">del</span> slots[x]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><p></p><p>在构建成本函数时有一条法则，即尽可能的让最优解的成本为0。对于本例中，最优解是所有的同学都被分配到了自己首选的宿舍。然后由于资源有限，我们是不可能得到最优解的，但是知道最优解的成本为0，我们便可以知道目前得到的解距离最有解的差距是多少。这个法则的另一个好处在于，我们找到最优解时，可以让算法停止后续的题解的搜索过程。</p><h2 id="执行优化函数"><a href="#执行优化函数" class="headerlink" title="执行优化函数"></a>执行优化函数</h2><p>有了题解的表示方法、成本函数、以及打印题解的函数，我们便可以用之前定义好的优化函数了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = randomoptimize(domain,dormcost)</span><br><span class="line">dormcost(s)</span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line">s = geneticoptimize(domain,dormcost)</span><br><span class="line"><span class="comment"># 13</span></span><br><span class="line"><span class="comment"># 10 </span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">printsolution(s)</span><br><span class="line"><span class="comment">#    Toby Athena</span></span><br><span class="line"><span class="comment">#    Steve Pluto</span></span><br><span class="line"><span class="comment">#    Andrea Zeus</span></span><br><span class="line"><span class="comment">#    Sarah Pluto</span></span><br><span class="line"><span class="comment">#    Dave Hercules</span></span><br><span class="line"><span class="comment">#    Jeff Hercules</span></span><br><span class="line"><span class="comment">#    Fred Bacchus</span></span><br><span class="line"><span class="comment">#    Suzie Bacchus</span></span><br><span class="line"><span class="comment">#    Laura Athena</span></span><br><span class="line"><span class="comment">#    Neil Zeus</span></span><br></pre></td></tr></table></figure><p></p><p>和之前一样，我们可以调整输入参数，看以看遗传优化算法是否能更快的找到一个优解。</p><h1 id="网络可视化"><a href="#网络可视化" class="headerlink" title="网络可视化"></a>网络可视化</h1><p>本小节向大家展示优化算法的另一个用途，这个问题与前面的问题没有丝毫的关联性。我们这里要讨论的是网络可视化的问题。此处的网络，意思是彼此相连的事物。像MySpace、Facebook或LinkedIn这的社会网络便是在线应用领域中存在网络结构的例子，人们因为互为朋友或具备特定关系而彼此相连。网站的每一个成员都可以选择与他相连的其他成员建立一个人际关系网络。将这一的网络可视化输出，用来明确人们彼此之间的关系结构，比如通过人际关系网络来认识新的朋友。</p><h2 id="布局问题"><a href="#布局问题" class="headerlink" title="布局问题"></a>布局问题</h2><p>为了展示一大群人及其彼此间的关联，我们将网络绘制成图，绘制时会遇到一个问题，我们应该如何安置图中每个人名（或头像)呢？先看看下面的那张图：<br><img src="/2018/01/07/optimization/confuse.jpg" title="混乱的网络布局"><br>从图中我们可以看出，Augustus是Willy、Violet、Miranda的朋友，但是网络的布局有点杂乱，而且增加更多的人会使得布局非常的混乱不堪。一个更为清晰的布局如下图所示：<br><img src="/2018/01/07/optimization/clean.jpg" title="清晰的网络布局"><br>本节中我们将考虑如何运用优化算法来构建更清晰的网络图。首先，我们新建一个名为socialnetwork.py的文件，并加入一些事实数据，这些数据代表着社会网络的某一个小部分：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">people=[<span class="string">'Charlie'</span>,<span class="string">'Augustus'</span>,<span class="string">'Veruca'</span>,<span class="string">'Violet'</span>,<span class="string">'Mike'</span>,<span class="string">'Joe'</span>,<span class="string">'Willy'</span>,<span class="string">'Miranda'</span>]</span><br><span class="line">links=[(<span class="string">'Augustus'</span>, <span class="string">'Willy'</span>),</span><br><span class="line">       (<span class="string">'Mike'</span>, <span class="string">'Joe'</span>),</span><br><span class="line">       (<span class="string">'Miranda'</span>, <span class="string">'Mike'</span>),</span><br><span class="line">       (<span class="string">'Violet'</span>, <span class="string">'Augustus'</span>),</span><br><span class="line">       (<span class="string">'Miranda'</span>, <span class="string">'Willy'</span>),</span><br><span class="line">       (<span class="string">'Charlie'</span>, <span class="string">'Mike'</span>),</span><br><span class="line">       (<span class="string">'Veruca'</span>, <span class="string">'Joe'</span>),</span><br><span class="line">       (<span class="string">'Miranda'</span>, <span class="string">'Augustus'</span>),</span><br><span class="line">       (<span class="string">'Willy'</span>, <span class="string">'Augustus'</span>),</span><br><span class="line">       (<span class="string">'Joe'</span>, <span class="string">'Charlie'</span>),</span><br><span class="line">       (<span class="string">'Veruca'</span>, <span class="string">'Augustus'</span>),</span><br><span class="line">       (<span class="string">'Miranda'</span>, <span class="string">'Joe'</span>)]</span><br></pre></td></tr></table></figure><p></p><p>此处，我们的目标是要建立一个程序，令其能够读取一组有关于谁是谁的朋友的事实数据，并生成一个清晰的网络图。要完成这些工作，通常需要借助于<strong>质点弹簧算法</strong>。这一算法是从物理学建模而来的：各节点彼此向对方施加推力来试图分离，而节点之间的连接则试图将有关联的节点彼此拉近。这样做的话，网络便会逐渐呈现出这样一个布局：未关联的节点被推离，而关联的节点则彼此拉近，却又不会紧紧的靠在一起。<br>遗憾的是，弹簧质点算法无法避免交叉线。这使得我们很难在一个拥有大量连接的网络中观察节点的连接的关联情况，因为追踪彼此交叉的连线是颇具难度的。不过，假如使用优化算法来构建布局的话，那么我们只需要一个成本函数，并尝试令它返回值尽可能的小。在本例中，一个值得一试的成本函数是计算交叉线的个数。</p><h2 id="计算交叉线"><a href="#计算交叉线" class="headerlink" title="计算交叉线"></a>计算交叉线</h2><p>为了能够使用早先定义过的那些优化函数，我们需要将题解表示为一个数值序列。所幸的是，将这一个特定问题的题解表示成一个数值序列是非常容易的——每个节点都有x坐标和y坐标，因此我们可以将所有节点的坐标放到一个列表中。<br>sol = [120,200,250,125……]<br>在上例中，Charlie位于(120,200),Augustus位于(250,125),以此类推。<br>成本函数只需要计算一下交叉线的个数即可。首先我们应该了解下，怎样来判断线段是否相交。</p><h3 id="判断线段是否交叉的数学基础"><a href="#判断线段是否交叉的数学基础" class="headerlink" title="判断线段是否交叉的数学基础"></a>判断线段是否交叉的数学基础</h3><p>这里要利用到外积公式：<br><img src="/2018/01/07/optimization/crossform.jpg" title="外积公式"><br>比较特别的情况是当两个向量平行的时候，外积为0。另外，叉乘的另外一个物理意义是如果通过小于180度的顺时针或逆时针旋转第一个向量，让它与第二个向量重叠。如果是顺时针转，叉乘小于0；如果是逆时针转，叉乘大于0。叉乘还有表示面积的物理含义，表示法向量的含义等等，这里不一一概述。<br>假设第一条线段是从点p到点p+r，而另外一条线段是从点q到点q+s，那么第一条线段上的点可以表示为p+tr，这里t是标量；同理，第二条线段上的点可以表示为q+us，这里u是标量。<br><img src="/2018/01/07/optimization/crossans.png" title="线段的向量表示"><br>对于相交点，意味着p + tr = q + us,如下图所示：<br><img src="/2018/01/07/optimization/crossansw.png" title="线段的交点的向量表示"><br>公式p + tr = q + us,两边叉乘s，可以得到下式:</p><blockquote><p>(p + tr) × s = (q + us) × s</p></blockquote><p>由于s × s = 0（两个向量平行叉乘为0）,化简会得到：</p><blockquote><p>t (r × s) = (q − p) × s</p></blockquote><p>进一步变形：</p><blockquote><p>t = (q − p) × s / (r × s)</p></blockquote><p>相同的计算过程可以求出u:</p><blockquote><p>(p + t r) × r = (q + u s) × r<br>u (s × r) = (p − q) × r<br>u = (p − q) × r / (s × r)</p></blockquote><p>根据公式：s × r = − r × s<br>我们可以将u改写为：</p><blockquote><p>u = (q − p) × r / (r × s)</p></blockquote><p>我们分三种情况讨论：</p><ol><li>如果r × s = 0 and (q − p) × r = 0，两个线段共线</li><li>r × s = 0 and (q − p) × r ≠ 0 ，两个线段平行，没有交点</li><li>r × s ≠ 0 and 0 ≤ t ≤ 1 and 0 ≤ u ≤ 1，两个直线存在交点</li><li>其他情况，两个直线处于不同的平面，既不相交也不平行。</li></ol><p>解法出处《Graphics Gems》作者 Ronald Goldman，小节Intersection of two lines in three-space，页码，304<br>计算两个线段是否相交的办法，还有“跨立实验”，它的意思是如果两个线段相交，那么线段的两个端点必然跨越另一条线段的两侧。这时候可以利用叉乘的向量旋转的性质，如果线段(q,q+s)的q，q+s两点跨立线段(p,p+r),那么向量（p,q+s）和向量(p,q)由向量(p,p+r)顺时针和逆时针旋转得到，它们的叉乘是负数;如果q，q+s没有跨立线段(p,p+r),那么向量（p,q+s）和向量(p,q)都是由向量(p,p+r)逆时针旋转或者顺时针旋转得到，它们的叉乘是正数。<br>参考文献：<br><a href="https://stackoverflow.com/questions/563198/whats-the-most-efficent-way-to-calculate-where-two-line-segments-intersect/565282#565282" target="_blank" rel="noopener">Stackoverflow 如何最有效的计算线段交点</a></p><h3 id="成本函数的表示"><a href="#成本函数的表示" class="headerlink" title="成本函数的表示"></a>成本函数的表示</h3><p>如果前面小节的两个参数t和u都在0-1之间，则这两个线段彼此交叉；反之，则不交叉<br>我们来遍历每一对连线，判断他们是否交叉。如果交叉，成本加1.<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crosscount</span><span class="params">(v)</span>:</span></span><br><span class="line">  <span class="comment"># 讲一个数字序列转换成一个人名与坐标点(x,y)的字典</span></span><br><span class="line">  loc = dict([(people[i],(v[i*<span class="number">2</span>],v[i*<span class="number">2</span>+<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(people))])</span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line">  <span class="comment">#遍历每一对连线</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(links)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(j+<span class="number">1</span>,len(links)):</span><br><span class="line">      <span class="comment">#获取坐标位置</span></span><br><span class="line">      (x1,y1),(x2,y2) = loc[links[i][<span class="number">0</span>],links[i][<span class="number">1</span>]]</span><br><span class="line">      (x3,y3),(x4,y4) = loc[links[j][<span class="number">0</span>],links[j][<span class="number">1</span>]]</span><br><span class="line">      <span class="comment">#r为(x2-x1,y2-y1),s为(x4-x3,y4-y3)</span></span><br><span class="line">      <span class="comment">#rs的叉乘为(x2-x1)(y4-y3)-(y2-y1)(x4-x3)</span></span><br><span class="line">      den=(x2-x1)*(y4-y3)-(y2-y1)(x4-x3)</span><br><span class="line">      <span class="comment">#如果两线平行，则叉乘为0</span></span><br><span class="line">      <span class="keyword">if</span> den ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      t = ((x3-x1)*(y4-y3)-(y3-y1)*(x4-x3))/den<span class="comment"># (q-p) × s 其中,p为(x1,y1) q为(x3,y3),q-p为(x3-x1,y3-y1)</span></span><br><span class="line">      u = ((x3-x1)*(y2-y1)-(y3-y1)*(x2-x1))/den<span class="comment"># (q-p) × r</span></span><br><span class="line">      <span class="comment"># 如果两条线段彼此交叉，则t和u都介于0-1之间</span></span><br><span class="line">      <span class="keyword">if</span> t&gt;<span class="number">0</span> <span class="keyword">and</span> t&lt;<span class="number">1</span> <span class="keyword">and</span> u&gt;<span class="number">0</span> <span class="keyword">and</span> u&lt;<span class="number">1</span>:</span><br><span class="line">        total+=<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><p></p><h3 id="使用优化函数进行优化"><a href="#使用优化函数进行优化" class="headerlink" title="使用优化函数进行优化"></a>使用优化函数进行优化</h3><p>现在来确定一下题解的定义域，假设我们将网络绘制在400*400像素的图中，我们可以规定x坐标和y坐标的坐标范围，考虑到要留一定的空白，我们给定的每个x和y坐标的定义域为(10,370)。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain = [(<span class="number">10</span>,<span class="number">370</span>)*len(people)*<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p></p><p>现在，我们可以尝试利用之前的优化算法，寻找极小有连线交叉情况的题解了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sol = randomoptimize(domain,crosscount)</span><br><span class="line">crosscount(sol)</span><br><span class="line"><span class="comment">#12</span></span><br><span class="line">sol = annealingoptimize(domain,crosscount)</span><br><span class="line">crosscount(sol)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">sol</span><br><span class="line"><span class="comment">#[324, 190, 241, 329, 298, 237, 117, 181, 88, 106, 56, 10, 296, 370, 11, 312]</span></span><br></pre></td></tr></table></figure><p></p><p>上述过程利用模拟退火算法找到了只有一个交叉线的题解，由于题解是坐标序列，我们需要将这个坐标序列转换成网络坐标图。</p><h3 id="绘制网络"><a href="#绘制网络" class="headerlink" title="绘制网络"></a>绘制网络</h3><p>绘制需要用到Pillow的python图像处理库，可通过pip install pillow来安装。<br>绘制网络的代码非常简单易懂。全部的代码要做的工作包括：建立一个image对象，绘制介于不同人之间的连线，并为每个人绘制相应的节点。我们将人名最后绘制，这样就不会被连线遮盖了。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawnetwork</span><span class="params">(sol)</span>:</span></span><br><span class="line">  <span class="comment">#建立image图像</span></span><br><span class="line">  img = Image.new(<span class="string">'RGB'</span>,(<span class="number">400</span>,<span class="number">400</span>),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">  draw = ImageDraw.Draw(img)</span><br><span class="line">  <span class="comment">#建立表示人和坐标信息的字典</span></span><br><span class="line">  pos = dict([(people[i],(sol[i*<span class="number">2</span>],sol[<span class="number">2</span>*i+<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(people))])</span><br><span class="line">  <span class="comment">#绘制连线</span></span><br><span class="line">  <span class="keyword">for</span> (a,b) <span class="keyword">in</span> links:</span><br><span class="line">    draw.line(pos[a],pos[b],fill=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">  <span class="comment">#绘制代表人物的节点</span></span><br><span class="line">  <span class="keyword">for</span> name,point <span class="keyword">in</span> pos.items():</span><br><span class="line">    draw.text(point,name,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">  img.show()</span><br></pre></td></tr></table></figure><p></p><p>调用该函数,传入上一小节得到的题解,便可以得到下图中的效果。<br><img src="/2018/01/07/optimization/nocross.jpg" title="没有交叉线的网络"><br>当然，你的题解可能会和上面的不一样。有时候题解可能看起来非常的古怪——这是因为我们的目标只是使得交叉线的数目最小化，成本函数中没有考虑两个连线之间的夹角很小或者两个点的距离非常近的布局情况。就这一点而言，优化算法就像是一个忠实满足你的天使一样。所以，清楚你想要什么是非常重要的。经常有题解满足原本的“最优”条件，但未必是一个考虑全面的结果。<br>如果要对两节点放置太近的题解进行“处罚”，最简单的办法就是计算两个节点间的距离并除上一个预估的最小距离。我们可以将下面代码添加到crosscount的末尾处，使成本函数可以考虑到节点之间的距离。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(people)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(people)):</span><br><span class="line">    <span class="comment">#获得两节点的位置</span></span><br><span class="line">    (x1,y1),(x2,y2)=loc[people[i]],loc[people[j]]</span><br><span class="line">    <span class="comment">#计算两节点的间距</span></span><br><span class="line">    dist = math.sqrt(math.pow(x1-x2,<span class="number">2</span>)+math.pow(y1-y2,<span class="number">2</span>))</span><br><span class="line">    <span class="comment">#对两节点之间间距小于50像素，增加惩罚</span></span><br><span class="line">    <span class="keyword">if</span> dist&lt;<span class="number">50</span>:</span><br><span class="line">      total +=(<span class="number">1.0</span>-(dist/<span class="number">50</span>))<span class="comment">#dist越小，成本加的越多</span></span><br></pre></td></tr></table></figure><p></p><p>当一对节点彼此间距小于50像素时，上述代码将产生一个比原来更高的成本值，增加的成本与距离的远近成比例。如果两个节点刚好重叠在一起，则成本要增加1.再次执行优化算法，看看能否形成一个分布较为开阔的布局。</p><h2 id="其他可能的应用场合"><a href="#其他可能的应用场合" class="headerlink" title="其他可能的应用场合"></a>其他可能的应用场合</h2><p>本章向大家展示了优化算法的三种截然不同的应用，但这只是众多可能的应用场合中很小的一部分。正如本章中一再强调的，关键的步骤在于确定题解的表示方法以及成本函数。如果能做到这些，那么我们就有机会利用优化算法来怼问题进行求解。<br>关于优化，还有可能的应用是：我们希望对一群人进行分组，让组内的技能相互取长补短。在一个小型的竞赛活动，我们喜欢每个队在体育、历史、文学、等等都有足够的知识。还有可能的情况是我们要根据人们的技能搭配情况，为项目组分配任务，优化算法可以找到任务分解的最佳方案，从而使任务列表在最短的时间内完成。<br>假设有一个长长的网站，其中每个网站都标注了关键字，根据用户提供的关键字集合来从这个长长的网站中寻找符合用户关键字的网站也可能是一件很有意义的事。符合用户提供的关键字集合的网站并不需要太多的公共的、彼此共有的关键字，而是尽可能的体现用户提供的关键字集合。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1.组团旅行的成本函数 请以飞机上每分钟0.50美元的成本将总飞行时间计人成本。然后再尝试追加20美元的罚款，以确保任何人都能在上午8点之前抵达机场。<br>感觉题目的描述有点问题<br>2.退火算法的初始值 模拟退火算法的结果很大程度上取决于其初始值。请构造一个新的优化函数，用多个初始直来模拟火，并返回最优解。<br>略<br>3、遗传优化算法的结束条件 本章中的函数是以固定迭代次数来进行遗传优化的。请改变算法的结束条件，使其在经过10次迭代之后，任一最优解都没有任何改善时，方才结束。<br>略<br>4，往返定价 此前通过kayak获取航班数据的函数查找的仅是单程航班。购买往返机票的价格可能会更加便宜。请修改代码取得往返票价，并修改成本函数，令其针对某一特定往返航班进行票价査询，而不是只对单程票价进行求和运算。<br>略<br>5.学兰组对 假设并非要求学生列出对宿舍的偏好，而是令其表达对同住舍友的偏好。那么你将如何表达学生组对的结果呢？成本函数又将如何定义呢?<br>略<br>6.连线夹角的判断 请在连接同一人的两线夹角非常小的时候，为网络布局算法的成本函数再增加一项成本。(提示可以使用向量的叉乘。)<br>略</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>如果您觉得读完本文有收获，不妨小额赞助我一下，让我有动力继续写出高质量的教程！</div><button id="rewardButton" disable="enable"><span>打赏</span></button><div id="QR" style="display:block"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/smacker.jpg" alt="倔强的土豆 微信支付"><p>微信支付</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/12/02/SearchAndRanking/" rel="next" title="搜索与排名"><i class="fa fa-chevron-left"></i> 搜索与排名</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/01/22/document-filtering/" rel="prev" title="文档过滤">文档过滤 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitment-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">倔强的土豆</p><p class="site-description motion-element" itemprop="description">分享机器学习、深度学习的点滴</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/laiqun" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:laiqun@msn.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#优化"><span class="nav-number">1.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组团旅游问题"><span class="nav-number">2.</span> <span class="nav-text">组团旅游问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述"><span class="nav-number">2.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解描述"><span class="nav-number">2.2.</span> <span class="nav-text">题解描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解评价（成本函数）"><span class="nav-number">2.3.</span> <span class="nav-text">题解评价（成本函数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化方法"><span class="nav-number">2.4.</span> <span class="nav-text">优化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机搜索"><span class="nav-number">2.4.1.</span> <span class="nav-text">随机搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爬山法"><span class="nav-number">2.4.2.</span> <span class="nav-text">爬山法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟退火算法"><span class="nav-number">2.4.3.</span> <span class="nav-text">模拟退火算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遗传算法"><span class="nav-number">2.4.4.</span> <span class="nav-text">遗传算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化算法总结"><span class="nav-number">2.4.5.</span> <span class="nav-text">优化算法总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#涉及偏好的优化——学生宿舍分配问题"><span class="nav-number">3.</span> <span class="nav-text">涉及偏好的优化——学生宿舍分配问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用优化算法解决问题的前提"><span class="nav-number">3.1.</span> <span class="nav-text">使用优化算法解决问题的前提</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-1"><span class="nav-number">3.2.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解的表示"><span class="nav-number">3.3.</span> <span class="nav-text">题解的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成本函数"><span class="nav-number">3.4.</span> <span class="nav-text">成本函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行优化函数"><span class="nav-number">3.5.</span> <span class="nav-text">执行优化函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络可视化"><span class="nav-number">4.</span> <span class="nav-text">网络可视化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#布局问题"><span class="nav-number">4.1.</span> <span class="nav-text">布局问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算交叉线"><span class="nav-number">4.2.</span> <span class="nav-text">计算交叉线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断线段是否交叉的数学基础"><span class="nav-number">4.2.1.</span> <span class="nav-text">判断线段是否交叉的数学基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成本函数的表示"><span class="nav-number">4.2.2.</span> <span class="nav-text">成本函数的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用优化函数进行优化"><span class="nav-number">4.2.3.</span> <span class="nav-text">使用优化函数进行优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制网络"><span class="nav-number">4.2.4.</span> <span class="nav-text">绘制网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他可能的应用场合"><span class="nav-number">4.3.</span> <span class="nav-text">其他可能的应用场合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习"><span class="nav-number">5.</span> <span class="nav-text">练习</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">倔强的土豆</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script><script type="text/javascript">function renderGitment(){var a=new Gitmint({id:window.location.pathname,owner:"laiqun",repo:"laiqun.github.io",lang:navigator.language||navigator.systemLanguage||navigator.userLanguage,oauth:{client_secret:"55aaeb736714431ea52109dd66461b1644ca6177",client_id:"c90dfa80285ea91b9120"}});a.render("gitment-container")}renderGitment()</script></body></html><!-- rebuild by neat -->