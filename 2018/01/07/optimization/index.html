<!-- build time:Wed Jan 17 2018 01:29:49 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、"><meta property="og:type" content="article"><meta property="og:title" content="优化"><meta property="og:url" content="laiqun.github.io/2018/01/07/optimization/index.html"><meta property="og:site_name" content="广阔天地，大有作为"><meta property="og:description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的使用该方法的典型场景：存在大量可能的题解，以至于我们无"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="/2018/01/07/optimization/climb.jpg"><meta property="og:image" content="/2018/01/07/optimization/localmin.jpg"><meta property="og:image" content="/2018/01/07/optimization/mutate.jpg"><meta property="og:image" content="/2018/01/07/optimization/cross.jpg"><meta property="og:image" content="/2018/01/07/optimization/poor.jpg"><meta property="og:updated_time" content="2018-01-16T17:28:53.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="优化"><meta name="twitter:description" content="优化本章将会教大家，如何使用一系列的随机优化 的技术来解决协作类问题。这种技术擅长处理：结果受多种变量影响有许多可能题解结果是变量的组合，变量组合变化，结果也跟着变应用场景举例：物理学 研究分子的运动生物学 预测蛋白质的结构计算机 确定算法的最坏运行时间NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的使用该方法的典型场景：存在大量可能的题解，以至于我们无"><meta name="twitter:image" content="/2018/01/07/optimization/climb.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="laiqun.github.io/2018/01/07/optimization/"><title>优化 | 广阔天地，大有作为</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">广阔天地，大有作为</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">你看到我的筋斗云了嘛？</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="laiqun.github.io/2018/01/07/optimization/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的土豆"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="广阔天地，大有作为"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">优化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-07T16:03:00+08:00">2018-01-07 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/01/07/optimization/#comments" itemprop="discussionUrl"><span class="post-comments-count gitment-comments-count" data-xid="/2018/01/07/optimization/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本章将会教大家，如何使用一系列的<strong>随机优化</strong> 的技术来解决协作类问题。<br>这种技术擅长处理：</p><ol><li>结果受多种变量影响</li><li>有许多可能题解</li><li>结果是变量的组合，变量组合变化，结果也跟着变</li></ol><p>应用场景举例：</p><ol><li>物理学 研究分子的运动</li><li>生物学 预测蛋白质的结构</li><li>计算机 确定算法的最坏运行时间</li><li>NASA 美国国家宇航局使用优化技术来设计具有正确操作特性的天线、天线的样子不像是人类设计的</li></ol><p>使用该方法的典型场景：存在大量可能的题解，以至于我们无法对它们进行一一尝试。<br>那么优化算法怎么找到一个问题的最优解的呢？<br>优化算法通过尝试许多不同题解，并给这些题解打分以确定题解的质量来找到一个问题的最优解。<br>最简单和最低效的做法的求解方法，进行上千次随机猜测，从随机猜测的题解中找出最佳解；更有效率的方法是以一种可能对题解有改进的方式来智能的修正现有的题解。<br>本文会演示3个例子来展示优化算法：<br>第一个例子是制定组团旅游计划：这个问题要考虑不同的输入：每个人的航班时间表、租用多少汽车、哪个飞机场比较顺畅。结果要考虑许多因素：总的花费、候机时间、飞机飞行的时间。对于这个问题，输入到输出之间的关系无法用简单的映射来表示。想找到最优解，必须借助优化算法。<br>第二个例子是如何基于人们的偏好来分配有限的资源。<br>第三个例子是如何用最小的交叉线来可视化网络结构。<br>第二个例子和第三个例子用于展示优化算法的灵活性。<br>最后，我们给出其他可以用到优化算法的场景。</p><h1 id="组团旅游问题"><a href="#组团旅游问题" class="headerlink" title="组团旅游问题"></a>组团旅游问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安排来自不同地方的人们到同一个地方旅游。<br>我们下创建一个python文件，写下不同的人物和它们的所在地信息。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">people = [(<span class="string">'Seymour'</span>,<span class="string">'BOS'</span>), <span class="comment"># 每一项的格式为人物名  所在地的机场名</span></span><br><span class="line">          (<span class="string">'Franny'</span>,<span class="string">'DAL'</span>),</span><br><span class="line">          (<span class="string">'Zooey'</span>,<span class="string">'CAK'</span>),</span><br><span class="line">          (<span class="string">'Walt'</span>,<span class="string">'MIA'</span>),</span><br><span class="line">          (<span class="string">'Buddy'</span>,<span class="string">'ORD'</span>),</span><br><span class="line">          (<span class="string">'Les'</span>,<span class="string">'OMA'</span>)]</span><br><span class="line"><span class="comment"># 目的地机场</span></span><br><span class="line">destination=<span class="string">'LGA'</span> <span class="comment"># New York的LAGuardia机场</span></span><br></pre></td></tr></table></figure><p></p><p>这些人来自各个地方，他们希望在纽约会面，他们将在同一天到达，在同一天回家。他们在纽约过夜一晚上，第二天返回原住地。他们想租汽车载着他们所有人往返机场。<br>下面我们来看一下航班数据，这些数据在文件scheule.txt中。<br>该文件的每一行代表一个航班数据,逗号作为数据项之间的间隔:<br>格式为: 起飞机场,目的地机场，起飞时间，抵达时间，费用<br>举例：</p><blockquote><p>LGA,MIA,20:27,23:42,169<br>MIA,LGA,19:53,22:21,173<br>LGA,BOS,6:39,8:09,86<br>BOS,LGA,6:17,8:26,89<br>LGA,BOS,8:23,10:28,149</p></blockquote><p>我们将这些数据载入到字典中，以(起点、终点)这样的元组为字典的键，以航班的详细信息为值，注意这里的值是一个列表，因为从起点到终点可能有多个航班。我们将这个列表排序，列表中的第一项代表第一个航班，第二项代表第二个航班，以此类推。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flights=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file(<span class="string">'schedule.txt'</span>):</span><br><span class="line">  origin,dest,depart,arrive,price=line.strip( ).split(<span class="string">','</span>)</span><br><span class="line">  flights.setdefault((origin,dest),[])</span><br><span class="line">  <span class="comment"># Add details to the list of possible flights</span></span><br><span class="line">  flights[(origin,dest)].append((depart,arrive,int(price)))</span><br></pre></td></tr></table></figure><p></p><p>为了方便的计算飞机飞行时间和候机时间，我们还需要编写一个工具函数，该函数计算给定时间在一天内的分钟数。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getminutes</span><span class="params">(t)</span>:</span></span><br><span class="line">       x=time.strptime(t,<span class="string">'%H:%M'</span>)</span><br><span class="line">       <span class="keyword">return</span> x[<span class="number">3</span>]*<span class="number">60</span>+x[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p></p><p>那他们中的每个成员应该坐哪个航班呢？<br>对于这个问题，降低总票价是一个目标，除此之外，还要考虑其他因素，如最小化总的候机时间或最小化总的飞行时间。</p><h2 id="题解描述"><a href="#题解描述" class="headerlink" title="题解描述"></a>题解描述</h2><p>当处理类似这样的优化问题时，我们必须明确潜在的题解应该如何表达。<br>因为后文中介绍的优化函数是非常通用的，它能应用在许多不同类型的问题上，因此我们需要选择一个题解的简单表示方式，要求这种表示方法不仅能表示当前问题的题解，还可以作为通用的题解表示方式。<br>这里我们使用数字序列来描述题解。<br>在本例中，一个数字代表某人乘坐的航班，因为每个人都都需要往返两个航班，故列表的长度是人数的的两倍。<br>[1,4,3,2,7,3,6,3,2,4,5,3] #数字0代表第1次航班，数字1代表第2次航班，以此类推。<br>上述列表描述了一种题解，数字1和4分别代表第2次航班和第5次航班，这表示Seymour搭乘当天的从Boston飞往New York的第2次航班，然后搭乘当天的从New York到Boston的第5次航班返回Boston。Franny是搭乘从Dallas到New York的第4次航班，并搭乘从New York到Dallas的第3次航班返回。<br>因为要从一列数字中解释清楚题解是很难的，所以我们写一个函数，能够将人民决定搭乘的所有航班打印成表格。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printschedule</span><span class="params">(r)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(r)/<span class="number">2</span>):</span><br><span class="line">    name = people[d][<span class="number">0</span>]</span><br><span class="line">    origin = people[d][<span class="number">1</span>]</span><br><span class="line">    out = flights[(origin,destination)][r[<span class="number">2</span>*d]] <span class="comment">#出行 out=[出发时间，返回时间，费用]</span></span><br><span class="line">    ret = flights[(origin,destination)][r[<span class="number">2</span>*d+<span class="number">1</span>]] <span class="comment">#返回</span></span><br><span class="line">    print(<span class="string">'%10s%10s %5s-%5s %3s %5s-%5s %3s'</span> % (name,origin,out[<span class="number">0</span>],out[<span class="number">1</span>],out[<span class="number">2</span>],ret[<span class="number">0</span>],ret[<span class="number">1</span>],ret[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p></p><p>我们来测试一下该函数，其打印的每一行格式为：人名、起点、出发时间、到达时间、票价、返航的出发时间、返航的到达时间、返航票价。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour  Boston 12:34-15:02 $109 12:08-14:05 $142</span></span><br><span class="line"><span class="comment"># Franny  Dallas 12:19-15:25 $342  9:49-13:51 $229</span></span><br><span class="line"><span class="comment">#  Zooey  Akron  9:15-12:14 $247 15:50-18:45 $243</span></span><br><span class="line"><span class="comment">#   Walt  Miami 15:34-18:11 $326 14:08-16:09 $232</span></span><br><span class="line"><span class="comment">#  Buddy  Chicago 14:22-16:32 $126 15:04-17:23 $189</span></span><br><span class="line"><span class="comment">#    Les  Omaha 15:03-16:42 $135  6:19- 8:13 $239</span></span><br></pre></td></tr></table></figure><p></p><p>我们现在来简单看一下这个题解的质量，我们发现Les会乘坐早上6点19的乘坐返航的飞机回家，因为他们往返机场都坐大巴士一起走的，所以即使Zooey虽然是下午3点50的航班，但也要和Les一起在早上6点19之前到达机场，很明显这样的组合不是很理想的，Zooey的候机时间太长。<br>为了确定最佳组合，我们需要一种方法来对题解进行评估，从而决定哪一个方案是最好的。</p><h2 id="题解评价（成本函数）"><a href="#题解评价（成本函数）" class="headerlink" title="题解评价（成本函数）"></a>题解评价（成本函数）</h2><p>成本函数是用优化算法解决问题的关键，它通常是最难确定的。任何优化算法的目标，就是寻找一组能够使成本函数达到最小值的输入。<br>成本函数用一个数值表示方案的好坏，其值越大，代表方案越差。<br>我们需要从众多变量来度量方案的好坏，以下是可能要考虑的度量因素。</p><ol><li>价格<br>所有航班的总票价，或者是考虑到每个旅客收入水平之后的加权平均。</li><li>飞行时间<br>每个旅客在飞机上花费的总时间。</li><li>等待时间<br>每个旅客在候机场等飞机的时间。以及一个旅客达到后，等待其他旅客的时间。</li><li>出发时间<br>越早的航班要求旅客越早起床，这会导致旅客的睡眠时间减少。</li><li>大巴的租用天数<br>大巴从起租时刻起，24小时内换回去，否则需要多租一天的巴士。巴士按天来租的。</li></ol><p>当我们为一个复杂问题寻找最佳方案的时候，倒要明确什么是最重要的因素。尽管寻找最重要的因素是由难度的，但一旦找到重要因素，制作少量的修改，便可以将优化算法来解决这个问题。<br>选择好对成本产生影响的一些变量之后，我们要寻找办法将他们组合在一起形成一个值。<br>例如在本例中，我们就有必要明确，在飞机上飞行的时间和在机场等待的时间怎么换算成价值，比如我们可以规定，飞机的飞行时间每减少1分钟，价值1美元。这意味着多花60美元可以减少1个小时的飞行时间。在机场候机的时间每一分钟价值0.5美元。巴士要租1天,如果超过了24小时，需要多付50美元。<br>下面我们来定义schedulecost函数，该函数考察了总的旅行时间成本以及不同旅客在机场总的等待时间。我们随时可以修改成本函数追加额外的成本，以及调整变量的重要性。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedulecost</span><span class="params">(sol)</span>:</span></span><br><span class="line">  totalprice=<span class="number">0</span></span><br><span class="line">  latestarrival =<span class="number">0</span></span><br><span class="line">  earliestdep = <span class="number">24</span>*<span class="number">60</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(sol)/<span class="number">2</span>):</span><br><span class="line">    <span class="comment">#得到去纽约的航班 以及从纽约回到原住地的航班</span></span><br><span class="line">    origin=people[d][<span class="number">1</span>]<span class="comment">#people每一项格式为 人名 原住地</span></span><br><span class="line">    outbound = flights[(origin,destination)][int(sol[<span class="number">2</span>*d])]<span class="comment">#格式为出发时间 到达时间 费用</span></span><br><span class="line">    returnf = flights[(destination,origin)][int(sol[<span class="number">2</span>*d+<span class="number">1</span>])]    </span><br><span class="line">    totalprice+=outbound[<span class="number">2</span>]</span><br><span class="line">    totalprice+=returnf[<span class="number">2</span>]</span><br><span class="line">   <span class="comment">#记录最晚到达的航班和最早离开的航班</span></span><br><span class="line">    <span class="keyword">if</span> latestarrival&lt;getminutes[outbound[<span class="number">1</span>]]:</span><br><span class="line">      latestarrival =getminutes[outbound[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">if</span> earliestdep&gt;getminutes[returnf[<span class="number">0</span>]]:</span><br><span class="line">      earliestdep=getminutes[returnf[<span class="number">0</span>]]</span><br><span class="line">    <span class="comment">#每个人必须在机场等待最后一个人的到达</span></span><br><span class="line">    <span class="comment">#他们返回时做同一个大巴，同一时间达到机场，等待他们的航班</span></span><br><span class="line">  totalwait=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> d <span class="keyword">in</span> range(len(sol)/<span class="number">2</span>):</span><br><span class="line">    origin = people[d][<span class="number">1</span>]</span><br><span class="line">    outbound = flights[(origin,destination)][int(sol[<span class="number">2</span>*d])]<span class="comment">#格式为出发时间 到达时间 费用</span></span><br><span class="line">    returnf = flights[(destination,origin)][int(sol[<span class="number">2</span>*d+<span class="number">1</span>])]    </span><br><span class="line">    totalwait+=latestarrival-getminutes(outbound[<span class="number">1</span>])</span><br><span class="line">    totalwait+=getminutes(returnf[<span class="number">0</span>])-earliestdep</span><br><span class="line">  <span class="keyword">if</span> latestarrival&lt;earliestdep:  </span><br><span class="line">  <span class="comment">#举例如果是早上6点租的，最早回去的是早上7点的航班</span></span><br><span class="line">  <span class="comment">#租的时间超过了24小时未还，需要多付50美元</span></span><br><span class="line">    totalprice+=<span class="number">50</span></span><br><span class="line">  <span class="keyword">return</span> totalprice+totalwait</span><br></pre></td></tr></table></figure><p></p><p>上述函数中的逻辑虽然非常简单，但是它却阐明了关键的因素。<br>我们还可以采用若干方法对其功能进行进行增强。<br>目前，总的等待时间的计算是假定：先到达纽约机场的旅客要等待最后一名达到机场的旅客。所有的旅客都有陪同最早回去的旅客到纽约机场，等他们各自的航班。<br>我们可以对方案的约束条件进行修改，如果旅客需要等待2小时以上时，他们可以自行搭出租，而不再需要一起坐巴士;我们还可以时间与价值量之间的权重，比如一分钟价值更多的美元或者更少的美元。<br>尝试运行一下上述函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedulecost([<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p></p><p>成本函数已经建立，那么应该很清楚，我们的目标就是通过选择比较合适的数字序列来最小化该成本函数。<br>里面上，我们可以尝试每种可能的组合，但这个例子中，假设每天有10个航班，达到纽约一个人有10种选择，那么6个人就有10000000种可能，如果算上返回的航班组合，又是1000000。将这两个组合起来就是10的12次方种方案，大概是1000亿。测试每种组合可以确保我们找到最优的方案，但这样将花费非常长的时间。</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><p>随机搜索不是一种非常好的优化算法，但是它却能使我们很容易领会的优化算法，就是随机猜呗。<br>这个函数接受两个参数。Domain是一个由二元组构成的列表，它指定额每个变量的最大值和最小值。用它来标识题解的搜索空间。在当前的例子中，每个人都有10种去纽约的航班和10种从纽约回到原住地的航班。因此domain是（0，9），每个人重复两次。<br>第二个参数，costf，是成本函数，本例中即为schedulecost。将成本函数作为参数传入是为了让这个随机搜索方法的优化函数能够被其他优化问题所用。<br>这个随机优化函数将会进行1000次猜测，然后对每种猜测计算成本，选中其中最好的题解。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomoptimize</span><span class="params">(domain,costf)</span>:</span></span><br><span class="line">  best = <span class="number">999999999</span></span><br><span class="line">  bestr = <span class="keyword">None</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment">#创建一个随机解</span></span><br><span class="line">    r=[random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i range(len(domain))]</span><br><span class="line">    <span class="comment">#计算这个随机解的成本</span></span><br><span class="line">    cost = costf(r)</span><br><span class="line">    <span class="comment">#与保留的历史最优解比较</span></span><br><span class="line">    <span class="keyword">if</span> cost&lt;best:</span><br><span class="line">      best = cost</span><br><span class="line">      bestr = r</span><br><span class="line">  <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p></p><p>1000次猜测只占全部可能的一小部分。我们可以随机猜测到不少表现还可以的题解，因为在猜测1000次后，该函数有可能得到一个看似不算很差的题解。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">domain=[(<span class="number">0</span>,<span class="number">9</span>)*(len(people)*<span class="number">2</span>)]</span><br><span class="line">s=randomoptimize(domain,schedulecost)<span class="comment">#得到随机猜测中的最优解</span></span><br><span class="line">schedulecost(s)<span class="comment">#计算猜测到的最优解的成本</span></span><br><span class="line">printschedule(s)<span class="comment">#打印结果</span></span><br><span class="line">Seymour  Boston <span class="number">12</span>:<span class="number">34</span><span class="number">-15</span>:<span class="number">02</span> $<span class="number">109</span> <span class="number">12</span>:<span class="number">08</span><span class="number">-14</span>:<span class="number">05</span> $<span class="number">142</span></span><br><span class="line"> Franny  Dallas <span class="number">12</span>:<span class="number">19</span><span class="number">-15</span>:<span class="number">25</span> $<span class="number">342</span>  <span class="number">9</span>:<span class="number">49</span><span class="number">-13</span>:<span class="number">51</span> $<span class="number">229</span></span><br><span class="line">  Zooey   Akron  <span class="number">9</span>:<span class="number">15</span><span class="number">-12</span>:<span class="number">14</span> $<span class="number">247</span> <span class="number">15</span>:<span class="number">50</span><span class="number">-18</span>:<span class="number">45</span> $<span class="number">243</span></span><br><span class="line">   Walt   Miami <span class="number">15</span>:<span class="number">34</span><span class="number">-18</span>:<span class="number">11</span> $<span class="number">326</span> <span class="number">14</span>:<span class="number">08</span><span class="number">-16</span>:<span class="number">09</span> $<span class="number">232</span></span><br><span class="line">  Buddy Chicago <span class="number">14</span>:<span class="number">22</span><span class="number">-16</span>:<span class="number">32</span> $<span class="number">126</span> <span class="number">15</span>:<span class="number">04</span><span class="number">-17</span>:<span class="number">23</span> $<span class="number">189</span></span><br><span class="line">    Les   Omaha <span class="number">15</span>:<span class="number">03</span><span class="number">-16</span>:<span class="number">42</span> $<span class="number">135</span>  <span class="number">6</span>:<span class="number">19</span>- <span class="number">8</span>:<span class="number">13</span> $<span class="number">239</span></span><br></pre></td></tr></table></figure><p></p><p>由于是随机的原因，你看到结果可能和这里不一样。上述结果不算很好，因为去纽约机场时，Zooey要等6个小时直到Walt到达。<br>我们可以多执行几次该函数，也可以将循环次数修改为10000，看看是不是能找到更有的结果。</p><h3 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h3><p>随机尝试各种题解是非常低效的，因为这种方法没有充分利用已经发现的优解。在我们的例子中，拥有较低成本的题解周围可能存在更优的题解。随机优化的题解是跳跃的，它不会充分利用已经发现的优解。<br>随机搜索的一种替代方法叫做爬山法。爬山法以一个随机解开始，然后在其临近的解集中寻找更好的解，更好的解拥有更低的成本。这类似于从斜坡上向下走，如图所示：<br><img src="/2018/01/07/optimization/climb.jpg" title="用爬山法寻找最低成本"><br>想象一下牛就是图中的那个人，不经意间陷入了这块区域中，并且想走到最低点去寻找水源。为此我们可以选择任何一个方向，然后朝着最为险峻的斜坡向下走去。你可以朝着最为险峻的斜坡方向一致走下去，直到达到地势平坦或者坡度开始向上倾斜的区域。<br>该优化方法的具体过程是：先从一个随机的方案开始，然后再找到所有与之相邻的题解。在本例中，即找到所有相对最初的题解，我们依次的挑出一个人，让他尝试乘坐稍早或者稍晚的航班。我们对这些相邻题解都计算成本，这一组相邻题解中最低成本的将成为新的题解。重复这个过程，直到不能改善为止。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hillclimb</span><span class="params">(domain,costf)</span>:</span></span><br><span class="line">  <span class="comment">#创建一个随机解</span></span><br><span class="line">  sol=[random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment">#生成相邻题解的集合</span></span><br><span class="line">    neighbors=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(domain)):</span><br><span class="line">      <span class="comment">#依次将每一项都提前或者延后一点的题解加入题解集合</span></span><br><span class="line">      <span class="keyword">if</span> sol[j]&gt;domain[j][<span class="number">0</span>]:<span class="comment">#最小值</span></span><br><span class="line">        neighbors.append(sol[<span class="number">0</span>:j]+[sol[j]<span class="number">-1</span>]+sol[j+<span class="number">1</span>:])</span><br><span class="line">      <span class="keyword">if</span> sol[j]&lt;domain[j][<span class="number">1</span>]:<span class="comment">#最大值</span></span><br><span class="line">        neighbors.append(sol[<span class="number">0</span>:j]+[sol[j]+<span class="number">1</span>]+sol[j+<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">#在相邻题解的集合中寻找最优解</span></span><br><span class="line">    current = costf(sol)</span><br><span class="line">    best = current<span class="comment">#得分</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(neighbors)):</span><br><span class="line">      cost = costf(neighbors[j])</span><br><span class="line">      <span class="keyword">if</span> cost&lt;best:</span><br><span class="line">        best = cost</span><br><span class="line">        sol = neighbors[j]</span><br><span class="line">    <span class="comment">#如果没有更好的解，退出循环</span></span><br><span class="line">    <span class="keyword">if</span> best == current:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> sol</span><br></pre></td></tr></table></figure><p></p><p>该函数在更定的域内随机生成了一个数字列表，用以构造初始的题解。它通过循环遍历列表中的每一个元素，将其加1和减一的题解作为新的题解，将新题解加入题解集合。然后对题解集合中的每一项计算成本函数，选择当前题解集合中的最优解。然后将这个题解作为初始解，重复上述过程。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hillclimb(domain,schedulecost) </span><br><span class="line">schedulecost(s)<span class="comment">#计算成本 </span></span><br><span class="line"><span class="comment">#3063</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour BOS 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny DAL 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey CAK 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt MIA 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy ORD 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les OMA 11:08-13:07 $175 18:25-20:34 $205</span></span><br></pre></td></tr></table></figure><p></p><p>该函数运行速度很快，并且找到的题解通常要比随机搜索找到的题解更优。然后，爬山法有一个很大的缺陷。如下图所示：<br><img src="/2018/01/07/optimization/localmin.jpg" title="陷入局部范围内的最小值"><br>从上图中我们可以明显的看出，简单的从斜坡滑下到达的可能未必是全局的最低点。最后的题解是一个局部范围内的最小值，它比临近的表现都好，但却不是全局最优的。全局最优解就是全局最小值，它是优化算法最终应该找到的那个题解。<br>解决这一难题的一种方法是随机重复爬山法，即让爬山法以多个随机生成的初始解为起点运行若干次，借此希望其中有一个能逼近全局的最小值。后面的模拟退火算法和遗传算法都是避免陷入局部最小值的优化方法。</p><h3 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h3><p>模拟退火算法是受物理学领域的启发而来的一种优化算法。退火是指将合金加热后再慢慢冷却的过程。大量的原子在温度较高时向周围跳跃，然后逐渐冷却，原子的性质逐渐稳定。<br>退火算法以一个问题的随机解开始，它用一个变量来表示温度，这个温度开始时非常高，然后逐渐变低。每一次迭代，算法会随机选择题解中的某个数字，然后朝着某个方向变化。然后计算其前后变化的成本，进行比较。<br>算法最为关键的部分在于：如果新的成本更低，则新的题解将会成为当前题解，这和爬山法类似。不过，如果成本更高的话，新的题解仍然有可能成为当前题解。这是避免局部最小值问题的一种方法。<br>某些情况下，在我们能够得到一个更优的解之前转向一个更差的解是很有必要的。模拟退火算法之所以管用，不仅因为它总是接受一个更优的解，还有就是他在退火过程的开始阶段会接受表现较差的解。随着退火过程的不断进行，算法越来越不可能接受较差的解，直到最后，它将只会接受更优的解。其接受差解的概率公式为：<br>p=e^((-highcost–lowcost)/temperature)<br>温度表示接受差解的意愿，开始非常高，指数将接近为0，所以概率几乎为1。随着温度的递减，高成本和低成本之间的差异越重要，差异越大，概率越低，因此该算法只倾向于稍差的解而不是非常差的解。<br>我们来书写annealingoptimize函数，来实现上述算法:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annealingoptimize</span><span class="params">(domain,costf,T=<span class="number">10000.0</span>,cool=<span class="number">0.95</span>,step=<span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="comment">#随机初始化值</span></span><br><span class="line">  vec = [float(random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">  <span class="keyword">while</span> T &gt;<span class="number">0.1</span>:</span><br><span class="line">    <span class="comment">#选择一个索引值</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(domain)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#选择一个改变索引值的方向</span></span><br><span class="line">    dir = random.randint(-step,step)</span><br><span class="line">    <span class="comment">#创建一个代表题解的新列表，改变其中一个值</span></span><br><span class="line">    vecb=vec[:]</span><br><span class="line">    vecb[i]+=dir</span><br><span class="line">    <span class="keyword">if</span> vecb[i]&lt;domain[i][<span class="number">0</span>]:</span><br><span class="line">      vecb[i]=domain[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> vecb[i]&gt;domain[i][<span class="number">1</span>]:</span><br><span class="line">      vecb[i]=domain[i][<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#计算当前成本和新的成本</span></span><br><span class="line">    ea = costf(vec)</span><br><span class="line">    eb = costf(vecb)</span><br><span class="line">    <span class="comment">#它是更好的解吗？或者取向最优解的可能解吗？</span></span><br><span class="line">    <span class="keyword">if</span> (eb&lt;ea <span class="keyword">or</span> random.rendom()&lt;pow(math.e,-(eb-ea)/T)):</span><br><span class="line">      vec=vecb</span><br><span class="line">    T=T*cool</span><br><span class="line">  <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p></p><p>为了退火，函数首先创建一个具有合适长度的随机解，其中所有值都位于定义域参数指定的范围内。<br>温度和冷却率是两个可选的参数。函数会在每次迭代时，将i设置为题解的一个随机索引，并将dir设置为介于-step和step之间的某个随机数。该算法会计算当前题解的成本，以及以i为索引增量dir的题解的成本。<br>概率计算的部分，概率的值会随着T的降低而降低。如果介于0到1之间的随机浮点数小于该值，或者新的题解更优，那么该函数会接受新的题解。函数会一致循环直到温度降到接近0为止，每次循环都会将温度值与冷却率相乘。<br>现在我们可以尝试运行该函数。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s=annealingoptimize(domain,schedulecost)</span><br><span class="line">schedulecost(s)</span><br><span class="line"><span class="comment">#2278</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour  Boston 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny  Dallas 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey   Akron 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt   Miami 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy Chicago 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les   Omaha 11:08-13:07 $175 15:07-17:21 $129</span></span><br></pre></td></tr></table></figure><p></p><p>你可能会得到不同的结果，深圳碰巧会得到一个较差的结果。对于任何一个给定的问题，可以尝试不同的参数来做试验，比如修改初始温度和冷却率，或者修改step值的大小。</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法也是受自然科学的启发。这类算法的运行过程是先随机生成一组解，我们称之为种群。<br>在优化算法的每一步，算法会计算整个种群的成本函数，从而得到一个题解与评分的有序列表。如下表所示。</p><table><thead><tr><th>题解</th><th>成本</th></tr></thead><tbody><tr><td>[7,5,2,3,1,6,1,6,7,1,0,3]</td><td>4394</td></tr><tr><td>[7,2,2,2,3,3,2,3,5,2,0,8]</td><td>4661</td></tr><tr><td>…</td><td>…</td></tr><tr><td>[0,4,0,3,8,8,4,4,8,5,6,1]</td><td>7845</td></tr><tr><td>[5,8,0,2,8,8,8,2,1,6,6,8]</td><td>8088</td></tr></tbody></table><p>在对题解进行排序之后，下一步我们要基于现有的种群产生一个新的种群——我们称之为下一代。<br>首先，我们将当期种群中位于最顶端的题解加入新种群，这一过程为<strong>精英选拔法</strong>。新种群中余下部分是修改最优解后形成的全新解组成的。<br>有两种修改题解的方法，其中一种较为简单的方法叫做<strong>变异</strong>，其通常的做法是对一个现有的题解进行微小的、简单的、随机的改变。<br>在本例中，要完成题解的变异只需要从题解中选择一个数字，然后对其进行递增或者递减即可。如下图所示：<br><img src="/2018/01/07/optimization/mutate.jpg" title="变异"><br>修改题解的另一种方法称之为<strong>分叉</strong>或者<strong>配对</strong>。这种方法是选取最优解中的两个解，然后将他们按某种方式进行组合。在本例中，要实现交叉的一种简单方式是，从一个解中随机取出一个数字作为新题解中的某些元素，而剩余的元素来自于另外一个题解。图下图所示：<br><img src="/2018/01/07/optimization/cross.jpg" title="配对"><br>一个新的种群是通过对最优解进行随机的<strong>变异</strong>和<strong>配对</strong>处理构造出来的，它的数目通常与旧种群的数目相同。这个过程会重复的进行——新的种群经过排序，又一个新种群被构造出来。达到指定的迭代次数，或者之后经过数代后题解都没有得到改善，整个过程就结束了。<br>下面我们编写函数实现上述算法：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneticoptimize</span><span class="params">(domain,costf,popsize=<span class="number">50</span>,step=<span class="number">1</span>,mutprob=<span class="number">0.2</span>,elite=<span class="number">0.2</span>,maxiter=<span class="number">100</span>)</span>:</span></span><br><span class="line">  <span class="comment">#变异操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mutate</span><span class="params">(vec)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(domain)<span class="number">-1</span>)<span class="comment">#随机选一项进行变异</span></span><br><span class="line">    <span class="keyword">if</span> random.random()&lt;<span class="number">0.5</span> <span class="keyword">and</span> vec[i]&gt;domain[i][<span class="number">0</span>]:</span><br><span class="line">      <span class="keyword">return</span> vec[<span class="number">0</span>:i]+[vec[i]-step]+vec[i+<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">elif</span> vec[i]&lt;domain[i][<span class="number">1</span>]:</span><br><span class="line">      <span class="keyword">return</span> vec[<span class="number">0</span>:i]+[vec[i]+step]+vec[i+<span class="number">1</span>:]</span><br><span class="line">  <span class="comment">#交叉操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crossover</span><span class="params">(r1,r2)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">1</span>,len(domain)<span class="number">-2</span>)<span class="comment">#确保至少交换1处</span></span><br><span class="line">    <span class="keyword">return</span> r1[<span class="number">0</span>:i]+r[i:]</span><br><span class="line">  <span class="comment">#构造初始种群</span></span><br><span class="line">  pop=[]<span class="comment">#构造一堆随机序列作为初始种群</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(popsize):</span><br><span class="line">    vec = [random.randint(domain[i][<span class="number">0</span>],domain[i][<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(domain))]</span><br><span class="line">    pop.append(vec)</span><br><span class="line">  <span class="comment">#每一代中有多少胜出者</span></span><br><span class="line">  topelite = int(elite*popsize)</span><br><span class="line">  <span class="comment">#主循环</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(maxiter):</span><br><span class="line">    scores = [ (cosft(v),v) <span class="keyword">for</span> v <span class="keyword">in</span> pop]<span class="comment">#socres每一项为： 成本 序列</span></span><br><span class="line">    scores.sort()</span><br><span class="line">    ranked=[v <span class="keyword">for</span> (s,v) <span class="keyword">in</span> scores]</span><br><span class="line">    <span class="comment">#只留下胜出者们</span></span><br><span class="line">    pop=ranked[<span class="number">0</span>:topelite]</span><br><span class="line">    <span class="comment">#添加变异和配对后胜出新的种群</span></span><br><span class="line">    <span class="keyword">while</span> len(pop)&lt;popsize:</span><br><span class="line">      <span class="keyword">if</span> random.random&lt;mutprob:</span><br><span class="line">        <span class="comment">#变异 从胜出者中随机选出一个进行变异</span></span><br><span class="line">        c = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        pop.append(mutate(ranked[c]))</span><br><span class="line">      <span class="keyword">else</span>：</span><br><span class="line">        <span class="comment">#配对 从胜出者中随机挑出两个进行配对</span></span><br><span class="line">        c1 = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        c2 = random.randint(<span class="number">0</span>,topelite)</span><br><span class="line">        pop.append(corssover(ranked[c1],ranked[c2]))</span><br><span class="line">    print(scores[<span class="number">0</span>][<span class="number">0</span>])<span class="comment">#打印最优解的成本</span></span><br><span class="line">  <span class="keyword">return</span> scores[<span class="number">0</span>][<span class="number">1</span>]<span class="comment">#打印最优解的序列</span></span><br></pre></td></tr></table></figure><p></p><p>上述函数中的几个可选的参数：</p><ol><li>popsize 意思是种群大小</li><li>mutprob 种群新成员是由变异而非配对得到的概率</li><li>elite 种群中被认为是优解且被允许传入下一代的部分</li><li>maxiter 最多迭代多少次</li></ol><p>尝试运行一下上述函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">geneticoptimize(domain,schedulecost)</span><br><span class="line"><span class="comment">#3532</span></span><br><span class="line"><span class="comment">#3503</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line"><span class="comment">#2591</span></span><br><span class="line">printschedule(s)</span><br><span class="line"><span class="comment">#Seymour BOS 12:34-15:02 $109 10:33-12:03 $ 74</span></span><br><span class="line"><span class="comment"># Franny DAL 10:30-14:57 $290 10:51-14:16 $256</span></span><br><span class="line"><span class="comment">#  Zooey CAK 10:53-13:36 $189 10:32-13:16 $139</span></span><br><span class="line"><span class="comment">#   Walt MIA 11:28-14:40 $248 12:37-15:05 $170</span></span><br><span class="line"><span class="comment">#  Buddy ORD 12:44-14:17 $134 10:33-13:11 $132</span></span><br><span class="line"><span class="comment">#    Les OMA 11:08-13:07 $175 11:07-13:24 $171</span></span><br></pre></td></tr></table></figure><p></p><p>后续我们会学习到遗传算法的一个扩展，称为<strong>遗传编程</strong>，在那里我们将使用类似的思路来自动构造程序。</p><blockquote><p>补充： 计算机科学家John Holland 因其在1975年所撰写的《Adaptation in Nature and Artificial System》，被认为是遗传算法之父。但是相关的研究工作可以追溯到1950年，那时的生物学家已经开始尝试在计算机上进行遗传进化的建模了。从那以后，遗传算法和其他优化算法已经被广泛的应用于许多不同的问题。比如:</p><ul><li>用来设计音乐厅的外形，使之能够产生最佳的音效</li><li>给超音速飞机设计最佳的机翼</li><li>加速药物的研发</li><li>自动化设计语音识别芯片<br>我们可以将这些问题的潜在解转化为数字列表。这一我们就可以很容易的应用遗传算法或模拟退火算法了。</li></ul></blockquote><h3 id="优化算法总结"><a href="#优化算法总结" class="headerlink" title="优化算法总结"></a>优化算法总结</h3><p>一种优化方法是否管用很大程序上取决于问题本身。模拟退火算法、遗传算法、以及大多数的其他优化算法都依赖于这样一个假设：对于大多数问题而言，最优解周围应该较多的优解。下面是一个优化算法很难起作用的例子，如下图所示：<br><img src="/2018/01/07/optimization/poor.jpg" title="很难优化的问题"><br>在图的最右边，成本的最低点处于一个非常陡峭的求。接近它的任何解都偶可能被排除在外，因为这些解的成本很高，所以我们可能永远也找不到通全局最小值的途径，大多数算法都会陷入图中左边的某个局部最小化的区域内。<br>优化方法对航班安排的例子之所以有效是因为，我们将一个人从当前的第二次航班转移到第三次航班，要比将他转移到第八次航班更有可能降低总成本。我们会在临近域中进行搜索。如果航班处于无序状态，那么优化方法的效果并不会被随机搜索好——实际上，在这样的情况下，没有任何一种优化方法一定会比随机搜索更加有效。</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>如果您觉得读完本文有收获，不妨小额赞助我一下，让我有动力继续写出高质量的教程！</div><button id="rewardButton" disable="enable"><span>打赏</span></button><div id="QR" style="display:block"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/smacker.jpg" alt="倔强的土豆 微信支付"><p>微信支付</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/12/02/SearchAndRanking/" rel="next" title="搜索与排名"><i class="fa fa-chevron-left"></i> 搜索与排名</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitment-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">倔强的土豆</p><p class="site-description motion-element" itemprop="description">分享机器学习、深度学习的点滴</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/laiqun" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:laiqun@msn.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#优化"><span class="nav-number">1.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组团旅游问题"><span class="nav-number">2.</span> <span class="nav-text">组团旅游问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述"><span class="nav-number">2.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解描述"><span class="nav-number">2.2.</span> <span class="nav-text">题解描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解评价（成本函数）"><span class="nav-number">2.3.</span> <span class="nav-text">题解评价（成本函数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化方法"><span class="nav-number">2.4.</span> <span class="nav-text">优化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机搜索"><span class="nav-number">2.4.1.</span> <span class="nav-text">随机搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爬山法"><span class="nav-number">2.4.2.</span> <span class="nav-text">爬山法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟退火算法"><span class="nav-number">2.4.3.</span> <span class="nav-text">模拟退火算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遗传算法"><span class="nav-number">2.4.4.</span> <span class="nav-text">遗传算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化算法总结"><span class="nav-number">2.4.5.</span> <span class="nav-text">优化算法总结</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">倔强的土豆</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script><script type="text/javascript">function renderGitment(){var a=new Gitmint({id:window.location.pathname,owner:"laiqun",repo:"laiqun.github.io",lang:navigator.language||navigator.systemLanguage||navigator.userLanguage,oauth:{client_secret:"55aaeb736714431ea52109dd66461b1644ca6177",client_id:"c90dfa80285ea91b9120"}});a.render("gitment-container")}renderGitment()</script></body></html><!-- rebuild by neat -->